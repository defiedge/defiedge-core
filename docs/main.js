/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={424:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>r});var a=n(81),i=n.n(a),o=n(645),s=n.n(o)()(i());s.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),s.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const r=s},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,o){"string"==typeof e&&(e=[[null,e,void 0]]);var s={};if(a)for(var r=0;r<this.length;r++){var p=this[r][0];null!=p&&(s[p]=!0)}for(var u=0;u<e.length;u++){var l=[].concat(e[u]);a&&s[l[0]]||(void 0!==o&&(void 0===l[5]||(l[1]="@layer".concat(l[5].length>0?" ".concat(l[5]):""," {").concat(l[1],"}")),l[5]=o),n&&(l[2]?(l[1]="@media ".concat(l[2]," {").concat(l[1],"}"),l[2]=n):l[2]=n),i&&(l[4]?(l[1]="@supports (".concat(l[4],") {").concat(l[1],"}"),l[4]=i):l[4]="".concat(i)),t.push(l))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},838:(e,t,n)=>{var a=n(424);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("20211576",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var o=t[i],s=o[0],r={id:e+":"+i,css:o[1],media:o[2],sourceMap:o[3]};a[s]?a[s].parts.push(r):n.push(a[s]={id:s,parts:[r]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var o={},s=i&&(document.head||document.getElementsByTagName("head")[0]),r=null,p=0,u=!1,l=function(){},d=null,y="data-vue-ssr-id",c="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){u=n,d=i||{};var s=a(e,t);return f(s),function(t){for(var n=[],i=0;i<s.length;i++){var r=s[i];(p=o[r.id]).refs--,n.push(p)}for(t?f(s=a(e,t)):s=[],i=0;i<n.length;i++){var p;if(0===(p=n[i]).refs){for(var u=0;u<p.parts.length;u++)p.parts[u]();delete o[p.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=o[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(b(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var s=[];for(i=0;i<n.parts.length;i++)s.push(b(n.parts[i]));o[n.id]={id:n.id,refs:1,parts:s}}}}function h(){var e=document.createElement("style");return e.type="text/css",s.appendChild(e),e}function b(e){var t,n,a=document.querySelector("style["+y+'~="'+e.id+'"]');if(a){if(u)return l;a.parentNode.removeChild(a)}if(c){var i=p++;a=r||(r=h()),t=w.bind(null,a,i,!1),n=w.bind(null,a,i,!0)}else a=h(),t=g.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var T,v=(T=[],function(e,t){return T[e]=t,T.filter(Boolean).join("\n")});function w(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=v(t,i);else{var o=document.createTextNode(i),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(o,s[t]):e.appendChild(o)}}function g(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),d.ssrId&&e.setAttribute(y,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var o=t[a]={id:a,exports:{}};return e[a](o,o.exports,n),o.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function o(e){return!0===e}function s(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function r(e){return"function"==typeof e}function p(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function l(e){return"[object Object]"===u.call(e)}function d(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function y(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function c(e){return null==e?"":Array.isArray(e)||l(e)&&e.toString===u?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function f(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var h=f("slot,component",!0),b=f("key,ref,slot,slot-scope,is");function T(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var v=Object.prototype.hasOwnProperty;function w(e,t){return v.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,M=g((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),I=g((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),_=/\B([A-Z])/g,x=g((function(e){return e.replace(_,"-$1").toLowerCase()})),R=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function S(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function C(e,t){for(var n in t)e[n]=t[n];return e}function A(e){for(var t={},n=0;n<e.length;n++)e[n]&&C(t,e[n]);return t}function P(e,t,n){}var E=function(e,t,n){return!1},F=function(e){return e};function O(e,t){if(e===t)return!0;var n=p(e),a=p(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),o=Array.isArray(t);if(i&&o)return e.length===t.length&&e.every((function(e,n){return O(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||o)return!1;var s=Object.keys(e),r=Object.keys(t);return s.length===r.length&&s.every((function(n){return O(e[n],t[n])}))}catch(e){return!1}}function q(e,t){for(var n=0;n<e.length;n++)if(O(e[n],t))return n;return-1}function U(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}function L(e,t){return e===t?0===e&&1/e!=1/t:e==e||t==t}var D="data-server-rendered",N=["component","directive","filter"],V=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],$={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:P,parsePlatformTagName:F,mustUseProp:E,async:!0,_lifecycleHooks:V},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function B(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function z(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var j=new RegExp("[^".concat(H.source,".$_\\d]")),W="__proto__"in{},G="undefined"!=typeof window,X=G&&window.navigator.userAgent.toLowerCase(),Q=X&&/msie|trident/.test(X),K=X&&X.indexOf("msie 9.0")>0,Y=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var J=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var Z,ee=X&&X.match(/firefox\/(\d+)/),te={}.watch,ne=!1;if(G)try{var ae={};Object.defineProperty(ae,"passive",{get:function(){ne=!0}}),window.addEventListener("test-passive",null,ae)}catch(e){}var ie=function(){return void 0===Z&&(Z=!G&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),Z},oe=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,pe="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);re="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ue=null;function le(e){void 0===e&&(e=null),e||ue&&ue._scope.off(),ue=e,e&&e._scope.on()}var de=function(){function e(e,t,n,a,i,o,s,r){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=r,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),ye=function(e){void 0===e&&(e="");var t=new de;return t.text=e,t.isComment=!0,t};function ce(e){return new de(void 0,void 0,void 0,String(e))}function me(e){var t=new de(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var fe=0,he=function(){function e(){this.id=fe++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){T(this.subs,e)},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.slice(),n=0,a=t.length;n<a;n++)t[n].update()},e}();he.target=null;var be=[];function Te(e){be.push(e),he.target=e}function ve(){be.pop(),he.target=be[be.length-1]}var we=Array.prototype,ge=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=we[e];z(ge,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,o=t.apply(this,n),s=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&s.observeArray(i),s.dep.notify(),o}))}));var ke=Object.getOwnPropertyNames(ge),Me={},Ie=!0;function _e(e){Ie=e}var xe={notify:P,depend:P,addSub:P,removeSub:P},Re=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?xe:new he,this.vmCount=0,z(e,"__ob__",this),t(e)){if(!a)if(W)e.__proto__=ge;else for(var i=0,o=ke.length;i<o;i++)z(e,r=ke[i],ge[r]);n||this.observeArray(e)}else{var s=Object.keys(e);for(i=0;i<s.length;i++){var r;Ce(e,r=s[i],Me,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Se(e[t],!1,this.mock)},e}();function Se(e,n,a){var i;if(!(!p(e)||qe(e)||e instanceof de))return w(e,"__ob__")&&e.__ob__ instanceof Re?i=e.__ob__:!Ie||!a&&ie()||!t(e)&&!l(e)||!Object.isExtensible(e)||e.__v_skip||(i=new Re(e,n,a)),i}function Ce(e,n,a,i,o,s){var r=new he,p=Object.getOwnPropertyDescriptor(e,n);if(!p||!1!==p.configurable){var u=p&&p.get,l=p&&p.set;u&&!l||a!==Me&&2!==arguments.length||(a=e[n]);var d=!o&&Se(a,!1,s);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=u?u.call(e):a;return he.target&&(r.depend(),d&&(d.dep.depend(),t(n)&&Ee(n))),qe(n)&&!o?n.value:n},set:function(t){var n=u?u.call(e):a;if(L(n,t)){if(l)l.call(e,t);else{if(u)return;if(!o&&qe(n)&&!qe(t))return void(n.value=t);a=t}d=!o&&Se(t,!1,s),r.notify()}}}),r}}function Ae(e,n,a){if(!Oe(e)){var i=e.__ob__;return t(e)&&d(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&Se(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Ce(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Pe(e,n){if(t(e)&&d(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||Oe(e)||w(e,n)&&(delete e[n],a&&a.dep.notify())}}function Ee(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Ee(n)}function Fe(e){return function(e,t){Oe(e)||Se(e,t,ie())}(e,!0),z(e,"__v_isShallow",!0),e}function Oe(e){return!(!e||!e.__v_isReadonly)}function qe(e){return!(!e||!0!==e.__v_isRef)}function Ue(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(qe(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];qe(a)&&!qe(e)?a.value=e:t[n]=e}})}var Le=g((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function De(e,n){function a(){var e=a.fns;if(!t(e))return Wt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),o=0;o<i.length;o++)Wt(i[o],null,arguments,n,"v-on handler")}return a.fns=e,a}function Ne(e,t,n,i,s,r){var p,u,l,d;for(p in e)u=e[p],l=t[p],d=Le(p),a(u)||(a(l)?(a(u.fns)&&(u=e[p]=De(u,r)),o(d.once)&&(u=e[p]=s(d.name,u,d.capture)),n(d.name,u,d.capture,d.passive,d.params)):u!==l&&(l.fns=u,e[p]=l));for(p in t)a(e[p])&&i((d=Le(p)).name,t[p],d.capture)}function Ve(e,t,n){var s;e instanceof de&&(e=e.data.hook||(e.data.hook={}));var r=e[t];function p(){n.apply(this,arguments),T(s.fns,p)}a(r)?s=De([p]):i(r.fns)&&o(r.merged)?(s=r).fns.push(p):s=De([r,p]),s.merged=!0,e[t]=s}function $e(e,t,n,a,o){if(i(t)){if(w(t,n))return e[n]=t[n],o||delete t[n],!0;if(w(t,a))return e[n]=t[a],o||delete t[a],!0}return!1}function He(e){return s(e)?[ce(e)]:t(e)?ze(e):void 0}function Be(e){return i(e)&&i(e.text)&&!1===e.isComment}function ze(e,n){var r,p,u,l,d=[];for(r=0;r<e.length;r++)a(p=e[r])||"boolean"==typeof p||(l=d[u=d.length-1],t(p)?p.length>0&&(Be((p=ze(p,"".concat(n||"","_").concat(r)))[0])&&Be(l)&&(d[u]=ce(l.text+p[0].text),p.shift()),d.push.apply(d,p)):s(p)?Be(l)?d[u]=ce(l.text+p):""!==p&&d.push(ce(p)):Be(p)&&Be(l)?d[u]=ce(l.text+p.text):(o(e._isVList)&&i(p.tag)&&a(p.key)&&i(n)&&(p.key="__vlist".concat(n,"_").concat(r,"__")),d.push(p)));return d}function je(e,n,a,u,l,d){return(t(a)||s(a))&&(l=u,u=a,a=void 0),o(d)&&(l=2),function(e,n,a,o,s){if(i(a)&&i(a.__ob__))return ye();if(i(a)&&i(a.is)&&(n=a.is),!n)return ye();var u,l;if(t(o)&&r(o[0])&&((a=a||{}).scopedSlots={default:o[0]},o.length=0),2===s?o=He(o):1===s&&(o=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(o)),"string"==typeof n){var d=void 0;l=e.$vnode&&e.$vnode.ns||$.getTagNamespace(n),u=$.isReservedTag(n)?new de($.parsePlatformTagName(n),a,o,void 0,void 0,e):a&&a.pre||!i(d=Nn(e.$options,"components",n))?new de(n,a,o,void 0,void 0,e):Cn(d,a,e,o,n)}else u=Cn(n,a,e,o);return t(u)?u:i(u)?(i(l)&&We(u,l),i(a)&&function(e){p(e.style)&&pn(e.style),p(e.class)&&pn(e.class)}(a),u):ye()}(e,n,a,u,l)}function We(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var s=0,r=e.children.length;s<r;s++){var p=e.children[s];i(p.tag)&&(a(p.ns)||o(n)&&"svg"!==p.tag)&&We(p,t,n)}}function Ge(e,n){var a,o,s,r,u=null;if(t(e)||"string"==typeof e)for(u=new Array(e.length),a=0,o=e.length;a<o;a++)u[a]=n(e[a],a);else if("number"==typeof e)for(u=new Array(e),a=0;a<e;a++)u[a]=n(a+1,a);else if(p(e))if(pe&&e[Symbol.iterator]){u=[];for(var l=e[Symbol.iterator](),d=l.next();!d.done;)u.push(n(d.value,u.length)),d=l.next()}else for(s=Object.keys(e),u=new Array(s.length),a=0,o=s.length;a<o;a++)r=s[a],u[a]=n(e[r],r,a);return i(u)||(u=[]),u._isVList=!0,u}function Xe(e,t,n,a){var i,o=this.$scopedSlots[e];o?(n=n||{},a&&(n=C(C({},a),n)),i=o(n)||(r(t)?t():t)):i=this.$slots[e]||(r(t)?t():t);var s=n&&n.slot;return s?this.$createElement("template",{slot:s},i):i}function Qe(e){return Nn(this.$options,"filters",e)||F}function Ke(e,n){return t(e)?-1===e.indexOf(n):e!==n}function Ye(e,t,n,a,i){var o=$.keyCodes[t]||n;return i&&a&&!$.keyCodes[t]?Ke(i,a):o?Ke(o,e):a?x(a)!==t:void 0===e}function Je(e,n,a,i,o){if(a&&p(a)){t(a)&&(a=A(a));var s=void 0,r=function(t){if("class"===t||"style"===t||b(t))s=e;else{var r=e.attrs&&e.attrs.type;s=i||$.mustUseProp(n,r,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var p=M(t),u=x(t);p in s||u in s||(s[t]=a[t],o&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var u in a)r(u)}return e}function Ze(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||tt(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function et(e,t,n){return tt(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function tt(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&nt(e[i],"".concat(n,"_").concat(i),a);else nt(e,n,a)}function nt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function at(e,t){if(t&&l(t)){var n=e.on=e.on?C({},e.on):{};for(var a in t){var i=n[a],o=t[a];n[a]=i?[].concat(i,o):o}}return e}function it(e,n,a,i){n=n||{$stable:!a};for(var o=0;o<e.length;o++){var s=e[o];t(s)?it(s,n,a):s&&(s.proxy&&(s.fn.proxy=!0),n[s.key]=s.fn)}return i&&(n.$key=i),n}function ot(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function st(e,t){return"string"==typeof e?t+e:e}function rt(e){e._o=et,e._n=m,e._s=c,e._l=Ge,e._t=Xe,e._q=O,e._i=q,e._m=Ze,e._f=Qe,e._k=Ye,e._b=Je,e._v=ce,e._e=ye,e._u=it,e._g=at,e._d=ot,e._p=st}function pt(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var o=e[a],s=o.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,o.context!==t&&o.fnContext!==t||!s||null==s.slot)(n.default||(n.default=[])).push(o);else{var r=s.slot,p=n[r]||(n[r]=[]);"template"===o.tag?p.push.apply(p,o.children||[]):p.push(o)}}for(var u in n)n[u].every(ut)&&delete n[u];return n}function ut(e){return e.isComment&&!e.asyncFactory||" "===e.text}function lt(e){return e.isComment&&e.asyncFactory}function dt(t,n,a,i){var o,s=Object.keys(a).length>0,r=n?!!n.$stable:!s,p=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(r&&i&&i!==e&&p===i.$key&&!s&&!i.$hasNormal)return i;for(var u in o={},n)n[u]&&"$"!==u[0]&&(o[u]=yt(t,a,u,n[u]))}else o={};for(var l in a)l in o||(o[l]=ct(a,l));return n&&Object.isExtensible(n)&&(n._normalized=o),z(o,"$stable",r),z(o,"$key",p),z(o,"$hasNormal",s),o}function yt(e,n,a,i){var o=function(){var n=ue;le(e);var a=arguments.length?i.apply(null,arguments):i({}),o=(a=a&&"object"==typeof a&&!t(a)?[a]:He(a))&&a[0];return le(n),a&&(!o||1===a.length&&o.isComment&&!lt(o))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:o,enumerable:!0,configurable:!0}),o}function ct(e,t){return function(){return e[t]}}function mt(e,t,n,a,i){var o=!1;for(var s in t)s in e?t[s]!==n[s]&&(o=!0):(o=!0,ft(e,s,a,i));for(var s in e)s in t||(o=!0,delete e[s]);return o}function ft(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function ht(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var bt,Tt=null;function vt(e,t){return(e.__esModule||pe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),p(e)?t.extend(e):e}function wt(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||lt(a)))return a}}function gt(e,t){bt.$on(e,t)}function kt(e,t){bt.$off(e,t)}function Mt(e,t){var n=bt;return function a(){var i=t.apply(null,arguments);null!==i&&n.$off(e,a)}}function It(e,t,n){bt=e,Ne(t,n||{},gt,kt,Mt,e),bt=void 0}var _t=null;function xt(e){var t=_t;return _t=e,function(){_t=t}}function Rt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function St(e,t){if(t){if(e._directInactive=!1,Rt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)St(e.$children[n]);At(e,"activated")}}function Ct(e,t){if(!(t&&(e._directInactive=!0,Rt(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Ct(e.$children[n]);At(e,"deactivated")}}function At(e,t,n,a){void 0===a&&(a=!0),Te();var i=ue;a&&le(e);var o=e.$options[t],s="".concat(t," hook");if(o)for(var r=0,p=o.length;r<p;r++)Wt(o[r],e,n||null,e,s);e._hasHookEvent&&e.$emit("hook:"+t),a&&le(i),ve()}var Pt=[],Et=[],Ft={},Ot=!1,qt=!1,Ut=0,Lt=0,Dt=Date.now;if(G&&!Q){var Nt=window.performance;Nt&&"function"==typeof Nt.now&&Dt()>document.createEvent("Event").timeStamp&&(Dt=function(){return Nt.now()})}var Vt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function $t(){var e,t;for(Lt=Dt(),qt=!0,Pt.sort(Vt),Ut=0;Ut<Pt.length;Ut++)(e=Pt[Ut]).before&&e.before(),t=e.id,Ft[t]=null,e.run();var n=Et.slice(),a=Pt.slice();Ut=Pt.length=Et.length=0,Ft={},Ot=qt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,St(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&At(a,"updated")}}(a),oe&&$.devtools&&oe.emit("flush")}var Ht,Bt="watcher";"".concat(Bt," callback"),"".concat(Bt," getter"),"".concat(Bt," cleanup");var zt=function(){function e(e){void 0===e&&(e=!1),this.active=!0,this.effects=[],this.cleanups=[],!e&&Ht&&(this.parent=Ht,this.index=(Ht.scopes||(Ht.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Ht;try{return Ht=this,e()}finally{Ht=t}}},e.prototype.on=function(){Ht=this},e.prototype.off=function(){Ht=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.active=!1}},e}();function jt(e,t,n){Te();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(a,e,t,n))return}catch(e){Gt(e,a,"errorCaptured hook")}}Gt(e,t,n)}finally{ve()}}function Wt(e,t,n,a,i){var o;try{(o=n?e.apply(t,n):e.call(t))&&!o._isVue&&y(o)&&!o._handled&&(o.catch((function(e){return jt(e,a,i+" (Promise/async)")})),o._handled=!0)}catch(e){jt(e,a,i)}return o}function Gt(e,t,n){if($.errorHandler)try{return $.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Xt(t)}Xt(e)}function Xt(e,t,n){if(!G||"undefined"==typeof console)throw e;console.error(e)}var Qt,Kt=!1,Yt=[],Jt=!1;function Zt(){Jt=!1;var e=Yt.slice(0);Yt.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&se(Promise)){var en=Promise.resolve();Qt=function(){en.then(Zt),J&&setTimeout(P)},Kt=!0}else if(Q||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Qt="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(Zt)}:function(){setTimeout(Zt,0)};else{var tn=1,nn=new MutationObserver(Zt),an=document.createTextNode(String(tn));nn.observe(an,{characterData:!0}),Qt=function(){tn=(tn+1)%2,an.data=String(tn)},Kt=!0}function on(e,t){var n;if(Yt.push((function(){if(e)try{e.call(t)}catch(e){jt(e,t,"nextTick")}else n&&n(t)})),Jt||(Jt=!0,Qt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function sn(e){return function(t,n){if(void 0===n&&(n=ue),n)return function(e,t,n){var a=e.$options;a[t]=qn(a[t],n)}(n,e,t)}}sn("beforeMount"),sn("mounted"),sn("beforeUpdate"),sn("updated"),sn("beforeDestroy"),sn("destroyed"),sn("activated"),sn("deactivated"),sn("serverPrefetch"),sn("renderTracked"),sn("renderTriggered"),sn("errorCaptured");var rn=new re;function pn(e){return un(e,rn),rn.clear(),e}function un(e,n){var a,i,o=t(e);if(!(!o&&!p(e)||Object.isFrozen(e)||e instanceof de)){if(e.__ob__){var s=e.__ob__.dep.id;if(n.has(s))return;n.add(s)}if(o)for(a=e.length;a--;)un(e[a],n);else if(qe(e))un(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)un(e[i[a]],n)}}var ln=0,dn=function(){function e(e,t,n,a,i){var o;void 0===(o=Ht&&!Ht._vm?Ht:e?e._scope:void 0)&&(o=Ht),o&&o.active&&o.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++ln,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="",r(t)?this.getter=t:(this.getter=function(e){if(!j.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;Te(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;jt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&pn(e),ve(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==Ft[t]&&(e!==he.target||!e.noRecurse)){if(Ft[t]=!0,qt){for(var n=Pt.length-1;n>Ut&&Pt[n].id>e.id;)n--;Pt.splice(n+1,0,e)}else Pt.push(e);Ot||(Ot=!0,on($t))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||p(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Wt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&T(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),yn={enumerable:!0,configurable:!0,get:P,set:P};function cn(e,t,n){yn.get=function(){return this[t][n]},yn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,yn)}function mn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Fe({}),i=e.$options._propKeys=[];e.$parent&&_e(!1);var o=function(o){i.push(o);var s=Vn(o,t,n,e);Ce(a,o,s),o in e||cn(e,"_props",o)};for(var s in t)o(s);_e(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};z(n,"_v_attr_proxy",!0),mt(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||mt(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||ht(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:R(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return Ue(t,e,n)}))}}}(t);le(t),Te();var o=Wt(a,null,[t._props||Fe({}),i],t,"setup");if(ve(),le(),r(o))n.render=o;else if(p(o))if(t._setupState=o,o.__sfc){var s=t._setupProxy={};for(var u in o)"__sfc"!==u&&Ue(s,o,u)}else for(var u in o)B(u)||Ue(t,o,u)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?P:R(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;l(t=e._data=r(t)?function(e,t){Te();try{return e.call(t,t)}catch(e){return jt(e,t,"data()"),{}}finally{ve()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var o=n[i];a&&w(a,o)||B(o)||cn(e,"_data",o)}var s=Se(t);s&&s.vmCount++}(n);else{var i=Se(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ie();for(var i in t){var o=t[i],s=r(o)?o:o.get;a||(n[i]=new dn(e,s||P,P,fn)),i in e||hn(e,i,o)}}(n,a.computed),a.watch&&a.watch!==te&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var o=0;o<i.length;o++)vn(e,a,i[o]);else vn(e,a,i)}}(n,a.watch)}var fn={lazy:!0};function hn(e,t,n){var a=!ie();r(n)?(yn.get=a?bn(t):Tn(n),yn.set=P):(yn.get=n.get?a&&!1!==n.cache?bn(t):Tn(n.get):P,yn.set=n.set||P),Object.defineProperty(e,t,yn)}function bn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),he.target&&t.depend(),t.value}}function Tn(e){return function(){return e.call(this,this)}}function vn(e,t,n,a){return l(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function wn(e,t){if(e){for(var n=Object.create(null),a=pe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var o=a[i];if("__ob__"!==o){var s=e[o].from;if(s in t._provided)n[o]=t._provided[s];else if("default"in e[o]){var p=e[o].default;n[o]=r(p)?p.call(t):p}}}return n}}var gn=0;function kn(e){var t=e.options;if(e.super){var n=kn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&C(e.extendOptions,a),(t=e.options=Dn(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Mn(n,a,i,s,r){var p,u=this,l=r.options;w(s,"_uid")?(p=Object.create(s))._original=s:(p=s,s=s._original);var d=o(l._compiled),y=!d;this.data=n,this.props=a,this.children=i,this.parent=s,this.listeners=n.on||e,this.injections=wn(l.inject,s),this.slots=function(){return u.$slots||dt(s,n.scopedSlots,u.$slots=pt(i,s)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return dt(s,n.scopedSlots,this.slots())}}),d&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=dt(s,n.scopedSlots,this.$slots)),l._scopeId?this._c=function(e,n,a,i){var o=je(p,e,n,a,i,y);return o&&!t(o)&&(o.fnScopeId=l._scopeId,o.fnContext=s),o}:this._c=function(e,t,n,a){return je(p,e,t,n,a,y)}}function In(e,t,n,a,i){var o=me(e);return o.fnContext=n,o.fnOptions=a,t.slot&&((o.data||(o.data={})).slot=t.slot),o}function _n(e,t){for(var n in t)e[M(n)]=t[n]}function xn(e){return e.name||e.__name||e._componentTag}rt(Mn.prototype);var Rn={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Rn.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,_t)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,o){var s=i.data.scopedSlots,r=t.$scopedSlots,p=!!(s&&!s.$stable||r!==e&&!r.$stable||s&&t.$scopedSlots.$key!==s.$key||!s&&t.$scopedSlots.$key),u=!!(o||t.$options._renderChildren||p),l=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=o;var d=i.data.attrs||e;t._attrsProxy&&mt(t._attrsProxy,d,l.data&&l.data.attrs||e,t,"$attrs")&&(u=!0),t.$attrs=d,a=a||e;var y=t.$options._parentListeners;if(t._listenersProxy&&mt(t._listenersProxy,a,y||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,It(t,a,y),n&&t.$options.props){_e(!1);for(var c=t._props,m=t.$options._propKeys||[],f=0;f<m.length;f++){var h=m[f],b=t.$options.props;c[h]=Vn(h,b,n,t)}_e(!0),t.$options.propsData=n}u&&(t.$slots=pt(o,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,At(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,Et.push(t)):St(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Ct(t,!0):t.$destroy())}},Sn=Object.keys(Rn);function Cn(n,s,r,u,l){if(!a(n)){var d=r.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var c;if(a(n.cid)&&(n=function(e,t){if(o(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=Tt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),o(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var s=e.owners=[n],r=!0,u=null,l=null;n.$on("hook:destroyed",(function(){return T(s,n)}));var d=function(e){for(var t=0,n=s.length;t<n;t++)s[t].$forceUpdate();e&&(s.length=0,null!==u&&(clearTimeout(u),u=null),null!==l&&(clearTimeout(l),l=null))},c=U((function(n){e.resolved=vt(n,t),r?s.length=0:d(!0)})),m=U((function(t){i(e.errorComp)&&(e.error=!0,d(!0))})),f=e(c,m);return p(f)&&(y(f)?a(e.resolved)&&f.then(c,m):y(f.component)&&(f.component.then(c,m),i(f.error)&&(e.errorComp=vt(f.error,t)),i(f.loading)&&(e.loadingComp=vt(f.loading,t),0===f.delay?e.loading=!0:u=setTimeout((function(){u=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,d(!1))}),f.delay||200)),i(f.timeout)&&(l=setTimeout((function(){l=null,a(e.resolved)&&m(null)}),f.timeout)))),r=!1,e.loading?e.loadingComp:e.resolved}}(c=n,d),void 0===n))return function(e,t,n,a,i){var o=ye();return o.asyncFactory=e,o.asyncMeta={data:t,context:n,children:a,tag:i},o}(c,s,r,u,l);s=s||{},kn(n),i(s.model)&&function(e,n){var a=e.model&&e.model.prop||"value",o=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var s=n.on||(n.on={}),r=s[o],p=n.model.callback;i(r)?(t(r)?-1===r.indexOf(p):r!==p)&&(s[o]=[p].concat(r)):s[o]=p}(n.options,s);var m=function(e,t,n){var o=t.options.props;if(!a(o)){var s={},r=e.attrs,p=e.props;if(i(r)||i(p))for(var u in o){var l=x(u);$e(s,p,u,l,!0)||$e(s,r,u,l,!1)}return s}}(s,n);if(o(n.options.functional))return function(n,a,o,s,r){var p=n.options,u={},l=p.props;if(i(l))for(var d in l)u[d]=Vn(d,l,a||e);else i(o.attrs)&&_n(u,o.attrs),i(o.props)&&_n(u,o.props);var y=new Mn(o,u,r,s,n),c=p.render.call(null,y._c,y);if(c instanceof de)return In(c,o,y.parent,p);if(t(c)){for(var m=He(c)||[],f=new Array(m.length),h=0;h<m.length;h++)f[h]=In(m[h],o,y.parent,p);return f}}(n,m,s,r,u);var f=s.on;if(s.on=s.nativeOn,o(n.options.abstract)){var h=s.slot;s={},h&&(s.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Sn.length;n++){var a=Sn[n],i=t[a],o=Rn[a];i===o||i&&i._merged||(t[a]=i?An(o,i):o)}}(s);var b=xn(n.options)||l;return new de("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),s,void 0,void 0,void 0,r,{Ctor:n,propsData:m,listeners:f,tag:l,children:u},c)}}}function An(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Pn=P,En=$.optionMergeStrategies;function Fn(e,t){if(!t)return e;for(var n,a,i,o=pe?Reflect.ownKeys(t):Object.keys(t),s=0;s<o.length;s++)"__ob__"!==(n=o[s])&&(a=e[n],i=t[n],w(e,n)?a!==i&&l(a)&&l(i)&&Fn(a,i):Ae(e,n,i));return e}function On(e,t,n){return n?function(){var a=r(t)?t.call(n,n):t,i=r(e)?e.call(n,n):e;return a?Fn(a,i):i}:t?e?function(){return Fn(r(t)?t.call(this,this):t,r(e)?e.call(this,this):e)}:t:e}function qn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function Un(e,t,n,a){var i=Object.create(e||null);return t?C(i,t):i}En.data=function(e,t,n){return n?On(e,t,n):t&&"function"!=typeof t?e:On(e,t)},V.forEach((function(e){En[e]=qn})),N.forEach((function(e){En[e+"s"]=Un})),En.watch=function(e,n,a,i){if(e===te&&(e=void 0),n===te&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var o={};for(var s in C(o,e),n){var r=o[s],p=n[s];r&&!t(r)&&(r=[r]),o[s]=r?r.concat(p):t(p)?p:[p]}return o},En.props=En.methods=En.inject=En.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return C(i,e),t&&C(i,t),i},En.provide=On;var Ln=function(e,t){return void 0===t?e:t};function Dn(e,n,a){if(r(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,o,s={};if(t(a))for(i=a.length;i--;)"string"==typeof(o=a[i])&&(s[M(o)]={type:null});else if(l(a))for(var r in a)o=a[r],s[M(r)]=l(o)?o:{type:o};e.props=s}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var o=0;o<a.length;o++)i[a[o]]={from:a[o]};else if(l(a))for(var s in a){var r=a[s];i[s]=l(r)?C({from:s},r):{from:r}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];r(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=Dn(e,n.extends,a)),n.mixins))for(var i=0,o=n.mixins.length;i<o;i++)e=Dn(e,n.mixins[i],a);var s,p={};for(s in e)u(s);for(s in n)w(e,s)||u(s);function u(t){var i=En[t]||Ln;p[t]=i(e[t],n[t],a,t)}return p}function Nn(e,t,n,a){if("string"==typeof n){var i=e[t];if(w(i,n))return i[n];var o=M(n);if(w(i,o))return i[o];var s=I(o);return w(i,s)?i[s]:i[n]||i[o]||i[s]}}function Vn(e,t,n,a){var i=t[e],o=!w(n,e),s=n[e],p=zn(Boolean,i.type);if(p>-1)if(o&&!w(i,"default"))s=!1;else if(""===s||s===x(e)){var u=zn(String,i.type);(u<0||p<u)&&(s=!0)}if(void 0===s){s=function(e,t,n){if(w(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:r(a)&&"Function"!==Hn(t.type)?a.call(e):a}}(a,i,e);var l=Ie;_e(!0),Se(s),_e(l)}return s}var $n=/^\s*function (\w+)/;function Hn(e){var t=e&&e.toString().match($n);return t?t[1]:""}function Bn(e,t){return Hn(e)===Hn(t)}function zn(e,n){if(!t(n))return Bn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Bn(n[a],e))return a;return-1}function jn(e){this._init(e)}function Wn(e){return e&&(xn(e.Ctor.options)||e.tag)}function Gn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==u.call(a))&&e.test(n));var a}function Xn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var o in n){var s=n[o];if(s){var r=s.name;r&&!t(r)&&Qn(n,o,a,i)}}}function Qn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,T(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=gn++,n._isVue=!0,n.__v_skip=!0,n._scope=new zt(!0),n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=Dn(kn(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&It(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=pt(n._renderChildren,i),t.$scopedSlots=a?dt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return je(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return je(t,e,n,a,i,!0)};var o=a&&a.data;Ce(t,"$attrs",o&&o.attrs||e,null,!0),Ce(t,"$listeners",n._parentListeners||e,null,!0)}(n),At(n,"beforeCreate",void 0,!1),function(e){var t=wn(e.$options.inject,e);t&&(_e(!1),Object.keys(t).forEach((function(n){Ce(e,n,t[n])})),_e(!0))}(n),mn(n),function(e){var t=e.$options.provide;if(t){var n=r(t)?t.call(e):t;if(!p(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=pe?Reflect.ownKeys(n):Object.keys(n),o=0;o<i.length;o++){var s=i[o];Object.defineProperty(a,s,Object.getOwnPropertyDescriptor(n,s))}}}(n),At(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(jn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ae,e.prototype.$delete=Pe,e.prototype.$watch=function(e,t,n){var a=this;if(l(t))return vn(a,e,t,n);(n=n||{}).user=!0;var i=new dn(a,e,t,n);if(n.immediate){var o='callback for immediate watcher "'.concat(i.expression,'"');Te(),Wt(t,a,[i.value],a,o),ve()}return function(){i.teardown()}}}(jn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var o=0,s=e.length;o<s;o++)i.$on(e[o],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,o=e.length;i<o;i++)a.$off(e[i],n);return a}var s,r=a._events[e];if(!r)return a;if(!n)return a._events[e]=null,a;for(var p=r.length;p--;)if((s=r[p])===n||s.fn===n){r.splice(p,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?S(n):n;for(var a=S(arguments,1),i='event handler for "'.concat(e,'"'),o=0,s=n.length;o<s;o++)Wt(n[o],t,a,t,i)}return t}}(jn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,o=xt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),o(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var s=n;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){At(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||T(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),At(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(jn),function(e){rt(e.prototype),e.prototype.$nextTick=function(e){return on(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,o=a._parentVnode;o&&n._isMounted&&(n.$scopedSlots=dt(n.$parent,o.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ht(n._slotsProxy,n.$scopedSlots)),n.$vnode=o;try{le(n),Tt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){jt(t,n,"render"),e=n._vnode}finally{Tt=null,le()}return t(e)&&1===e.length&&(e=e[0]),e instanceof de||(e=ye()),e.parent=o,e}}(jn);var Kn=[String,RegExp,Array],Yn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kn,exclude:Kn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var o=a.tag,s=a.componentInstance,r=a.componentOptions;t[i]={name:Wn(r),tag:o,componentInstance:s},n.push(i),this.max&&n.length>parseInt(this.max)&&Qn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Qn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Xn(e,(function(e){return Gn(t,e)}))})),this.$watch("exclude",(function(t){Xn(e,(function(e){return!Gn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=wt(e),n=t&&t.componentOptions;if(n){var a=Wn(n),i=this.include,o=this.exclude;if(i&&(!a||!Gn(i,a))||o&&a&&Gn(o,a))return t;var s=this.cache,r=this.keys,p=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;s[p]?(t.componentInstance=s[p].componentInstance,T(r,p),r.push(p)):(this.vnodeToCache=t,this.keyToCache=p),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return $}};Object.defineProperty(e,"config",t),e.util={warn:Pn,extend:C,mergeOptions:Dn,defineReactive:Ce},e.set=Ae,e.delete=Pe,e.nextTick=on,e.observable=function(e){return Se(e),e},e.options=Object.create(null),N.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,C(e.options.components,Yn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=S(arguments,1);return n.unshift(this),r(e.install)?e.install.apply(e,n):r(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Dn(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var o=xn(e)||xn(n.options),s=function(e){this._init(e)};return(s.prototype=Object.create(n.prototype)).constructor=s,s.cid=t++,s.options=Dn(n.options,e),s.super=n,s.options.props&&function(e){var t=e.options.props;for(var n in t)cn(e.prototype,"_props",n)}(s),s.options.computed&&function(e){var t=e.options.computed;for(var n in t)hn(e.prototype,n,t[n])}(s),s.extend=n.extend,s.mixin=n.mixin,s.use=n.use,N.forEach((function(e){s[e]=n[e]})),o&&(s.options.components[o]=s),s.superOptions=n.options,s.extendOptions=e,s.sealedOptions=C({},s.options),i[a]=s,s}}(e),function(e){N.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&l(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&r(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(jn),Object.defineProperty(jn.prototype,"$isServer",{get:ie}),Object.defineProperty(jn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(jn,"FunctionalRenderContext",{value:Mn}),jn.version="2.7.10";var Jn=f("style,class"),Zn=f("input,textarea,option,select,progress"),ea=function(e,t,n){return"value"===n&&Zn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},ta=f("contenteditable,draggable,spellcheck"),na=f("events,caret,typing,plaintext-only"),aa=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",oa=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},sa=function(e){return oa(e)?e.slice(6,e.length):""},ra=function(e){return null==e||!1===e};function pa(e,t){return{staticClass:ua(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function ua(e,t){return e?t?e+" "+t:e:t||""}function la(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,o=e.length;a<o;a++)i(t=la(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):p(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var da={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ya=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ca=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ma=function(e){return ya(e)||ca(e)};function fa(e){return ca(e)?"svg":"math"===e?"math":void 0}var ha=Object.create(null),ba=f("text,number,password,search,email,tel,url");function Ta(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var va=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(da[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),wa={create:function(e,t){ga(t)},update:function(e,t){e.data.ref!==t.data.ref&&(ga(e,!0),ga(t))},destroy:function(e){ga(e,!0)}};function ga(e,n){var a=e.data.ref;if(i(a)){var o=e.context,s=e.componentInstance||e.elm,p=n?null:s,u=n?void 0:s;if(r(a))Wt(a,o,[p],o,"template ref function");else{var l=e.data.refInFor,d="string"==typeof a||"number"==typeof a,y=qe(a),c=o.$refs;if(d||y)if(l){var m=d?c[a]:a.value;n?t(m)&&T(m,s):t(m)?m.includes(s)||m.push(s):d?(c[a]=[s],ka(o,a,c[a])):a.value=[s]}else if(d){if(n&&c[a]!==s)return;c[a]=u,ka(o,a,p)}else if(y){if(n&&a.value!==s)return;a.value=p}}}}function ka(e,t,n){var a=e._setupState;a&&w(a,t)&&(qe(a[t])?a[t].value=n:a[t]=n)}var Ma=new de("",{},[]),Ia=["create","activate","update","remove","destroy"];function _a(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,o=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===o||ba(a)&&ba(o)}(e,t)||o(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function xa(e,t,n){var a,o,s={};for(a=t;a<=n;++a)i(o=e[a].key)&&(s[o]=a);return s}var Ra={create:Sa,update:Sa,destroy:function(e){Sa(e,Ma)}};function Sa(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,o=e===Ma,s=t===Ma,r=Aa(e.data.directives,e.context),p=Aa(t.data.directives,t.context),u=[],l=[];for(n in p)a=r[n],i=p[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Ea(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(Ea(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var d=function(){for(var n=0;n<u.length;n++)Ea(u[n],"inserted",t,e)};o?Ve(t,"insert",d):d()}if(l.length&&Ve(t,"postpatch",(function(){for(var n=0;n<l.length;n++)Ea(l[n],"componentUpdated",t,e)})),!o)for(n in r)p[n]||Ea(r[n],"unbind",e,e,s)}(e,t)}var Ca=Object.create(null);function Aa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Ca),i[Pa(a)]=a,t._setupState&&t._setupState.__sfc){var o=a.def||Nn(t,"_setupState","v-"+a.name);a.def="function"==typeof o?{bind:o,update:o}:o}a.def=a.def||Nn(t.$options,"directives",a.name)}return i}function Pa(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Ea(e,t,n,a,i){var o=e.def&&e.def[t];if(o)try{o(n.elm,e,n,a,i)}catch(a){jt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var Fa=[wa,Ra];function Oa(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var s,r,p=t.elm,u=e.data.attrs||{},l=t.data.attrs||{};for(s in(i(l.__ob__)||o(l._v_attr_proxy))&&(l=t.data.attrs=C({},l)),l)r=l[s],u[s]!==r&&qa(p,s,r,t.data.pre);for(s in(Q||Y)&&l.value!==u.value&&qa(p,"value",l.value),u)a(l[s])&&(oa(s)?p.removeAttributeNS(ia,sa(s)):ta(s)||p.removeAttribute(s))}}function qa(e,t,n,a){a||e.tagName.indexOf("-")>-1?Ua(e,t,n):aa(t)?ra(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):ta(t)?e.setAttribute(t,function(e,t){return ra(t)||"false"===t?"false":"contenteditable"===e&&na(t)?t:"true"}(t,n)):oa(t)?ra(n)?e.removeAttributeNS(ia,sa(t)):e.setAttributeNS(ia,t,n):Ua(e,t,n)}function Ua(e,t,n){if(ra(n))e.removeAttribute(t);else{if(Q&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var La={create:Oa,update:Oa};function Da(e,t){var n=t.elm,o=t.data,s=e.data;if(!(a(o.staticClass)&&a(o.class)&&(a(s)||a(s.staticClass)&&a(s.class)))){var r=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=pa(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=pa(t,n.data));return o=t.staticClass,s=t.class,i(o)||i(s)?ua(o,la(s)):"";var o,s}(t),p=n._transitionClasses;i(p)&&(r=ua(r,la(p))),r!==n._prevClass&&(n.setAttribute("class",r),n._prevClass=r)}}var Na,Va,$a,Ha,Ba,za,ja={create:Da,update:Da},Wa=/[\w).+\-_$\]]/;function Ga(e){var t,n,a,i,o,s=!1,r=!1,p=!1,u=!1,l=0,d=0,y=0,c=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),s)39===t&&92!==n&&(s=!1);else if(r)34===t&&92!==n&&(r=!1);else if(p)96===t&&92!==n&&(p=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||l||d||y){switch(t){case 34:r=!0;break;case 39:s=!0;break;case 96:p=!0;break;case 40:y++;break;case 41:y--;break;case 91:d++;break;case 93:d--;break;case 123:l++;break;case 125:l--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Wa.test(f)||(u=!0)}}else void 0===i?(c=a+1,i=e.slice(0,a).trim()):h();function h(){(o||(o=[])).push(e.slice(c,a).trim()),c=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==c&&h(),o)for(a=0;a<o.length;a++)i=Xa(i,o[a]);return i}function Xa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Qa(e,t){console.error("[Vue compiler]: ".concat(e))}function Ka(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Ya(e,t,n,a,i){(e.props||(e.props=[])).push(si({name:t,value:n,dynamic:i},a)),e.plain=!1}function Ja(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(si({name:t,value:n,dynamic:i},a)),e.plain=!1}function Za(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(si({name:t,value:n},a))}function ei(e,t,n,a,i,o,s,r){(e.directives||(e.directives=[])).push(si({name:t,rawName:n,value:a,arg:i,isDynamicArg:o,modifiers:s},r)),e.plain=!1}function ti(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ni(t,n,a,i,o,s,r,p){var u;(i=i||e).right?p?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(p?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=ti("!",n,p)),i.once&&(delete i.once,n=ti("~",n,p)),i.passive&&(delete i.passive,n=ti("&",n,p)),i.native?(delete i.native,u=t.nativeEvents||(t.nativeEvents={})):u=t.events||(t.events={});var l=si({value:a.trim(),dynamic:p},r);i!==e&&(l.modifiers=i);var d=u[n];Array.isArray(d)?o?d.unshift(l):d.push(l):u[n]=d?o?[l,d]:[d,l]:l,t.plain=!1}function ai(e,t,n){var a=ii(e,":"+t)||ii(e,"v-bind:"+t);if(null!=a)return Ga(a);if(!1!==n){var i=ii(e,t);if(null!=i)return JSON.stringify(i)}}function ii(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,o=0,s=i.length;o<s;o++)if(i[o].name===t){i.splice(o,1);break}return n&&delete e.attrsMap[t],a}function oi(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var o=n[a];if(t.test(o.name))return n.splice(a,1),o}}function si(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function ri(e,t,n){var a=n||{},i=a.number,o="$$v",s=o;a.trim&&(s="(typeof ".concat(o," === 'string'")+"? ".concat(o,".trim()")+": ".concat(o,")")),i&&(s="_n(".concat(s,")"));var r=pi(t,s);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(o,") {").concat(r,"}")}}function pi(e,t){var n=function(e){if(e=e.trim(),Na=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Na-1)return(Ha=e.lastIndexOf("."))>-1?{exp:e.slice(0,Ha),key:'"'+e.slice(Ha+1)+'"'}:{exp:e,key:null};for(Va=e,Ha=Ba=za=0;!li();)di($a=ui())?ci($a):91===$a&&yi($a);return{exp:e.slice(0,Ba),key:e.slice(Ba+1,za)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function ui(){return Va.charCodeAt(++Ha)}function li(){return Ha>=Na}function di(e){return 34===e||39===e}function yi(e){var t=1;for(Ba=Ha;!li();)if(di(e=ui()))ci(e);else if(91===e&&t++,93===e&&t--,0===t){za=Ha;break}}function ci(e){for(var t=e;!li()&&(e=ui())!==t;);}var mi;function fi(e,t,n){var a=mi;return function i(){var o=t.apply(null,arguments);null!==o&&Ti(e,i,n,a)}}var hi=Kt&&!(ee&&Number(ee[1])<=53);function bi(e,t,n,a){if(hi){var i=Lt,o=t;t=o._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return o.apply(this,arguments)}}mi.addEventListener(e,t,ne?{capture:n,passive:a}:n)}function Ti(e,t,n,a){(a||mi).removeEventListener(e,t._wrapper||t,n)}function vi(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},o=e.data.on||{};mi=t.elm||e.elm,function(e){if(i(e.__r)){var t=Q?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}i(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(n),Ne(n,o,bi,Ti,fi,t.context),mi=void 0}}var wi,gi={create:vi,update:vi,destroy:function(e){return vi(e,Ma)}};function ki(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,s,r=t.elm,p=e.data.domProps||{},u=t.data.domProps||{};for(n in(i(u.__ob__)||o(u._v_attr_proxy))&&(u=t.data.domProps=C({},u)),p)n in u||(r[n]="");for(n in u){if(s=u[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),s===p[n])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===n&&"PROGRESS"!==r.tagName){r._value=s;var l=a(s)?"":String(s);Mi(r,l)&&(r.value=l)}else if("innerHTML"===n&&ca(r.tagName)&&a(r.innerHTML)){(wi=wi||document.createElement("div")).innerHTML="<svg>".concat(s,"</svg>");for(var d=wi.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(s!==p[n])try{r[n]=s}catch(e){}}}}function Mi(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Ii={create:ki,update:ki},_i=g((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function xi(e){var t=Ri(e.style);return e.staticStyle?C(e.staticStyle,t):t}function Ri(e){return Array.isArray(e)?A(e):"string"==typeof e?_i(e):e}var Si,Ci=/^--/,Ai=/\s*!important$/,Pi=function(e,t,n){if(Ci.test(t))e.style.setProperty(t,n);else if(Ai.test(n))e.style.setProperty(x(t),n.replace(Ai,""),"important");else{var a=Fi(t);if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)e.style[a]=n[i];else e.style[a]=n}},Ei=["Webkit","Moz","ms"],Fi=g((function(e){if(Si=Si||document.createElement("div").style,"filter"!==(e=M(e))&&e in Si)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Ei.length;n++){var a=Ei[n]+t;if(a in Si)return a}}));function Oi(e,t){var n=t.data,o=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(o.staticStyle)&&a(o.style))){var s,r,p=t.elm,u=o.staticStyle,l=o.normalizedStyle||o.style||{},d=u||l,y=Ri(t.data.style)||{};t.data.normalizedStyle=i(y.__ob__)?C({},y):y;var c=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=xi(i.data))&&C(a,n);(n=xi(e.data))&&C(a,n);for(var o=e;o=o.parent;)o.data&&(n=xi(o.data))&&C(a,n);return a}(t);for(r in d)a(c[r])&&Pi(p,r,"");for(r in c)(s=c[r])!==d[r]&&Pi(p,r,null==s?"":s)}}var qi={create:Oi,update:Oi},Ui=/\s+/;function Li(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Di(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ui).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Ni(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&C(t,Vi(e.name||"v")),C(t,e),t}return"string"==typeof e?Vi(e):void 0}}var Vi=g((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),$i=G&&!K,Hi="transition",Bi="animation",zi="transition",ji="transitionend",Wi="animation",Gi="animationend";$i&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(zi="WebkitTransition",ji="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wi="WebkitAnimation",Gi="webkitAnimationEnd"));var Xi=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Qi(e){Xi((function(){Xi(e)}))}function Ki(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Li(e,t))}function Yi(e,t){e._transitionClasses&&T(e._transitionClasses,t),Di(e,t)}function Ji(e,t,n){var a=eo(e,t),i=a.type,o=a.timeout,s=a.propCount;if(!i)return n();var r=i===Hi?ji:Gi,p=0,u=function(){e.removeEventListener(r,l),n()},l=function(t){t.target===e&&++p>=s&&u()};setTimeout((function(){p<s&&u()}),o+1),e.addEventListener(r,l)}var Zi=/\b(transform|all)(,|$)/;function eo(e,t){var n,a=window.getComputedStyle(e),i=(a[zi+"Delay"]||"").split(", "),o=(a[zi+"Duration"]||"").split(", "),s=to(i,o),r=(a[Wi+"Delay"]||"").split(", "),p=(a[Wi+"Duration"]||"").split(", "),u=to(r,p),l=0,d=0;return t===Hi?s>0&&(n=Hi,l=s,d=o.length):t===Bi?u>0&&(n=Bi,l=u,d=p.length):d=(n=(l=Math.max(s,u))>0?s>u?Hi:Bi:null)?n===Hi?o.length:p.length:0,{type:n,timeout:l,propCount:d,hasTransform:n===Hi&&Zi.test(a[zi+"Property"])}}function to(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return no(t)+no(e[n])})))}function no(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ao(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var o=Ni(e.data.transition);if(!a(o)&&!i(n._enterCb)&&1===n.nodeType){for(var s=o.css,u=o.type,l=o.enterClass,d=o.enterToClass,y=o.enterActiveClass,c=o.appearClass,f=o.appearToClass,h=o.appearActiveClass,b=o.beforeEnter,T=o.enter,v=o.afterEnter,w=o.enterCancelled,g=o.beforeAppear,k=o.appear,M=o.afterAppear,I=o.appearCancelled,_=o.duration,x=_t,R=_t.$vnode;R&&R.parent;)x=R.context,R=R.parent;var S=!x._isMounted||!e.isRootInsert;if(!S||k||""===k){var C=S&&c?c:l,A=S&&h?h:y,P=S&&f?f:d,E=S&&g||b,F=S&&r(k)?k:T,O=S&&M||v,q=S&&I||w,L=m(p(_)?_.enter:_),D=!1!==s&&!K,N=so(F),V=n._enterCb=U((function(){D&&(Yi(n,P),Yi(n,A)),V.cancelled?(D&&Yi(n,C),q&&q(n)):O&&O(n),n._enterCb=null}));e.data.show||Ve(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),F&&F(n,V)})),E&&E(n),D&&(Ki(n,C),Ki(n,A),Qi((function(){Yi(n,C),V.cancelled||(Ki(n,P),N||(oo(L)?setTimeout(V,L):Ji(n,u,V)))}))),e.data.show&&(t&&t(),F&&F(n,V)),D||N||V()}}}function io(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var o=Ni(e.data.transition);if(a(o)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var s=o.css,r=o.type,u=o.leaveClass,l=o.leaveToClass,d=o.leaveActiveClass,y=o.beforeLeave,c=o.leave,f=o.afterLeave,h=o.leaveCancelled,b=o.delayLeave,T=o.duration,v=!1!==s&&!K,w=so(c),g=m(p(T)?T.leave:T),k=n._leaveCb=U((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),v&&(Yi(n,l),Yi(n,d)),k.cancelled?(v&&Yi(n,u),h&&h(n)):(t(),f&&f(n)),n._leaveCb=null}));b?b(M):M()}function M(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),y&&y(n),v&&(Ki(n,u),Ki(n,d),Qi((function(){Yi(n,u),k.cancelled||(Ki(n,l),w||(oo(g)?setTimeout(k,g):Ji(n,r,k)))}))),c&&c(n,k),v||w||k())}}function oo(e){return"number"==typeof e&&!isNaN(e)}function so(e){if(a(e))return!1;var t=e.fns;return i(t)?so(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ro(e,t){!0!==t.data.show&&ao(t)}var po=function(e){var n,r,p={},u=e.modules,l=e.nodeOps;for(n=0;n<Ia.length;++n)for(p[Ia[n]]=[],r=0;r<u.length;++r)i(u[r][Ia[n]])&&p[Ia[n]].push(u[r][Ia[n]]);function d(e){var t=l.parentNode(e);i(t)&&l.removeChild(t,e)}function y(e,t,n,a,s,r,u){if(i(e.elm)&&i(r)&&(e=r[u]=me(e)),e.isRootInsert=!s,!function(e,t,n,a){var s=e.data;if(i(s)){var r=i(e.componentInstance)&&s.keepAlive;if(i(s=s.hook)&&i(s=s.init)&&s(e,!1),i(e.componentInstance))return c(e,t),m(n,e.elm,a),o(r)&&function(e,t,n,a){for(var o,s=e;s.componentInstance;)if(i(o=(s=s.componentInstance._vnode).data)&&i(o=o.transition)){for(o=0;o<p.activate.length;++o)p.activate[o](Ma,s);t.push(s);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var d=e.data,y=e.children,f=e.tag;i(f)?(e.elm=e.ns?l.createElementNS(e.ns,f):l.createElement(f,e),v(e),h(e,y,t),i(d)&&T(e,t),m(n,e.elm,a)):o(e.isComment)?(e.elm=l.createComment(e.text),m(n,e.elm,a)):(e.elm=l.createTextNode(e.text),m(n,e.elm,a))}}function c(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,b(e)?(T(e,t),v(e)):(ga(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?l.parentNode(n)===e&&l.insertBefore(e,t,n):l.appendChild(e,t))}function h(e,n,a){if(t(n))for(var i=0;i<n.length;++i)y(n[i],a,e.elm,null,!0,n,i);else s(e.text)&&l.appendChild(e.elm,l.createTextNode(String(e.text)))}function b(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function T(e,t){for(var a=0;a<p.create.length;++a)p.create[a](Ma,e);i(n=e.data.hook)&&(i(n.create)&&n.create(Ma,e),i(n.insert)&&t.push(e))}function v(e){var t;if(i(t=e.fnScopeId))l.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&l.setStyleScope(e.elm,t),n=n.parent;i(t=_t)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&l.setStyleScope(e.elm,t)}function w(e,t,n,a,i,o){for(;a<=i;++a)y(n[a],o,e,t,!1,n,a)}function g(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<p.destroy.length;++t)p.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)g(e.children[n])}function k(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(M(a),g(a)):d(a.elm))}}function M(e,t){if(i(t)||i(e.data)){var n,a=p.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&d(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&M(n,t),n=0;n<p.remove.length;++n)p.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else d(e.elm)}function I(e,t,n,a){for(var o=n;o<a;o++){var s=t[o];if(i(s)&&_a(e,s))return o}}function _(e,t,n,s,r,u){if(e!==t){i(t.elm)&&i(s)&&(t=s[r]=me(t));var d=t.elm=e.elm;if(o(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?S(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(o(t.isStatic)&&o(e.isStatic)&&t.key===e.key&&(o(t.isCloned)||o(t.isOnce)))t.componentInstance=e.componentInstance;else{var c,m=t.data;i(m)&&i(c=m.hook)&&i(c=c.prepatch)&&c(e,t);var f=e.children,h=t.children;if(i(m)&&b(t)){for(c=0;c<p.update.length;++c)p.update[c](e,t);i(c=m.hook)&&i(c=c.update)&&c(e,t)}a(t.text)?i(f)&&i(h)?f!==h&&function(e,t,n,o,s){for(var r,p,u,d=0,c=0,m=t.length-1,f=t[0],h=t[m],b=n.length-1,T=n[0],v=n[b],g=!s;d<=m&&c<=b;)a(f)?f=t[++d]:a(h)?h=t[--m]:_a(f,T)?(_(f,T,o,n,c),f=t[++d],T=n[++c]):_a(h,v)?(_(h,v,o,n,b),h=t[--m],v=n[--b]):_a(f,v)?(_(f,v,o,n,b),g&&l.insertBefore(e,f.elm,l.nextSibling(h.elm)),f=t[++d],v=n[--b]):_a(h,T)?(_(h,T,o,n,c),g&&l.insertBefore(e,h.elm,f.elm),h=t[--m],T=n[++c]):(a(r)&&(r=xa(t,d,m)),a(p=i(T.key)?r[T.key]:I(T,t,d,m))?y(T,o,e,f.elm,!1,n,c):_a(u=t[p],T)?(_(u,T,o,n,c),t[p]=void 0,g&&l.insertBefore(e,u.elm,f.elm)):y(T,o,e,f.elm,!1,n,c),T=n[++c]);d>m?w(e,a(n[b+1])?null:n[b+1].elm,n,c,b,o):c>b&&k(t,d,m)}(d,f,h,n,u):i(h)?(i(e.text)&&l.setTextContent(d,""),w(d,null,h,0,h.length-1,n)):i(f)?k(f,0,f.length-1):i(e.text)&&l.setTextContent(d,""):e.text!==t.text&&l.setTextContent(d,t.text),i(m)&&i(c=m.hook)&&i(c=c.postpatch)&&c(e,t)}}}function x(e,t,n){if(o(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var R=f("attrs,class,staticClass,staticStyle,key");function S(e,t,n,a){var s,r=t.tag,p=t.data,u=t.children;if(a=a||p&&p.pre,t.elm=e,o(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(p)&&(i(s=p.hook)&&i(s=s.init)&&s(t,!0),i(s=t.componentInstance)))return c(t,n),!0;if(i(r)){if(i(u))if(e.hasChildNodes())if(i(s=p)&&i(s=s.domProps)&&i(s=s.innerHTML)){if(s!==e.innerHTML)return!1}else{for(var l=!0,d=e.firstChild,y=0;y<u.length;y++){if(!d||!S(d,u[y],n,a)){l=!1;break}d=d.nextSibling}if(!l||d)return!1}else h(t,u,n);if(i(p)){var m=!1;for(var f in p)if(!R(f)){m=!0,T(t,n);break}!m&&p.class&&pn(p.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,s){if(!a(t)){var r,u=!1,d=[];if(a(e))u=!0,y(t,d);else{var c=i(e.nodeType);if(!c&&_a(e,t))_(e,t,d,null,null,s);else{if(c){if(1===e.nodeType&&e.hasAttribute(D)&&(e.removeAttribute(D),n=!0),o(n)&&S(e,t,d))return x(t,d,!0),e;r=e,e=new de(l.tagName(r).toLowerCase(),{},[],void 0,r)}var m=e.elm,f=l.parentNode(m);if(y(t,d,m._leaveCb?null:f,l.nextSibling(m)),i(t.parent))for(var h=t.parent,T=b(t);h;){for(var v=0;v<p.destroy.length;++v)p.destroy[v](h);if(h.elm=t.elm,T){for(var w=0;w<p.create.length;++w)p.create[w](Ma,h);var M=h.data.hook.insert;if(M.merged)for(var I=1;I<M.fns.length;I++)M.fns[I]()}else ga(h);h=h.parent}i(f)?k([e],0,0):i(e.tag)&&g(e)}}return x(t,d,u),t.elm}i(e)&&g(e)}}({nodeOps:va,modules:[La,ja,gi,Ii,qi,G?{create:ro,activate:ro,remove:function(e,t){!0!==e.data.show?io(e,t):t()}}:{}].concat(Fa)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&bo(e,"input")}));var uo={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?Ve(n,"postpatch",(function(){uo.componentUpdated(e,t,n)})):lo(e,t,n.context),e._vOptions=[].map.call(e.options,mo)):("textarea"===n.tag||ba(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",fo),e.addEventListener("compositionend",ho),e.addEventListener("change",ho),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){lo(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,mo);i.some((function(e,t){return!O(e,a[t])}))&&(e.multiple?t.value.some((function(e){return co(e,i)})):t.value!==t.oldValue&&co(t.value,i))&&bo(e,"change")}}};function lo(e,t,n){yo(e,t),(Q||Y)&&setTimeout((function(){yo(e,t)}),0)}function yo(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var o,s,r=0,p=e.options.length;r<p;r++)if(s=e.options[r],i)o=q(a,mo(s))>-1,s.selected!==o&&(s.selected=o);else if(O(mo(s),a))return void(e.selectedIndex!==r&&(e.selectedIndex=r));i||(e.selectedIndex=-1)}}function co(e,t){return t.every((function(t){return!O(t,e)}))}function mo(e){return"_value"in e?e._value:e.value}function fo(e){e.target.composing=!0}function ho(e){e.target.composing&&(e.target.composing=!1,bo(e.target,"input"))}function bo(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function To(e){return!e.componentInstance||e.data&&e.data.transition?e:To(e.componentInstance._vnode)}var vo={model:uo,show:{bind:function(e,t,n){var a=t.value,i=(n=To(n)).data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,ao(n,(function(){e.style.display=o}))):e.style.display=a?o:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=To(n)).data&&n.data.transition?(n.data.show=!0,a?ao(n,(function(){e.style.display=e.__vOriginalDisplay})):io(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},wo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function go(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?go(wt(t.children)):e}function ko(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[M(a)]=i[a];return t}function Mo(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var Io=function(e){return e.tag||lt(e)},_o=function(e){return"show"===e.name},xo={name:"transition",props:wo,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(Io)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var o=go(i);if(!o)return i;if(this._leaving)return Mo(e,i);var r="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?r+"comment":r+o.tag:s(o.key)?0===String(o.key).indexOf(r)?o.key:r+o.key:o.key;var p=(o.data||(o.data={})).transition=ko(this),u=this._vnode,l=go(u);if(o.data.directives&&o.data.directives.some(_o)&&(o.data.show=!0),l&&l.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(o,l)&&!lt(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var d=l.data.transition=C({},p);if("out-in"===a)return this._leaving=!0,Ve(d,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Mo(e,i);if("in-out"===a){if(lt(o))return u;var y,c=function(){y()};Ve(p,"afterEnter",c),Ve(p,"enterCancelled",c),Ve(d,"delayLeave",(function(e){y=e}))}}return i}}},Ro=C({tag:String,moveClass:String},wo);delete Ro.mode;var So={props:Ro,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=xt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],s=ko(this),r=0;r<i.length;r++)(l=i[r]).tag&&null!=l.key&&0!==String(l.key).indexOf("__vlist")&&(o.push(l),n[l.key]=l,(l.data||(l.data={})).transition=s);if(a){var p=[],u=[];for(r=0;r<a.length;r++){var l;(l=a[r]).data.transition=s,l.data.pos=l.elm.getBoundingClientRect(),n[l.key]?p.push(l):u.push(l)}this.kept=e(t,null,p),this.removed=u}return e(t,null,o)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Co),e.forEach(Ao),e.forEach(Po),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Ki(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(ji,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(ji,e),n._moveCb=null,Yi(n,t))})}})))},methods:{hasMove:function(e,t){if(!$i)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Di(n,e)})),Li(n,t),n.style.display="none",this.$el.appendChild(n);var a=eo(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Co(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Ao(e){e.data.newPos=e.elm.getBoundingClientRect()}function Po(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),o.transitionDuration="0s"}}var Eo={Transition:xo,TransitionGroup:So};jn.config.mustUseProp=ea,jn.config.isReservedTag=ma,jn.config.isReservedAttr=Jn,jn.config.getTagNamespace=fa,jn.config.isUnknownElement=function(e){if(!G)return!0;if(ma(e))return!1;if(e=e.toLowerCase(),null!=ha[e])return ha[e];var t=document.createElement(e);return e.indexOf("-")>-1?ha[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ha[e]=/HTMLUnknownElement/.test(t.toString())},C(jn.options.directives,vo),C(jn.options.components,Eo),jn.prototype.__patch__=G?po:P,jn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=ye),At(e,"beforeMount"),a=function(){e._update(e._render(),n)},new dn(e,a,P,{before:function(){e._isMounted&&!e._isDestroyed&&At(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var o=0;o<i.length;o++)i[o].run();return null==e.$vnode&&(e._isMounted=!0,At(e,"mounted")),e}(this,e=e&&G?Ta(e):void 0,t)},G&&setTimeout((function(){$.devtools&&oe&&oe.emit("init",jn)}),0);var Fo,Oo=/\{\{((?:.|\r?\n)+?)\}\}/g,qo=/[-.*+?^${}()|[\]\/\\]/g,Uo=g((function(e){var t=e[0].replace(qo,"\\$&"),n=e[1].replace(qo,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Lo={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ii(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=ai(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Do={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ii(e,"style");n&&(e.staticStyle=JSON.stringify(_i(n)));var a=ai(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},No=f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Vo=f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),$o=f("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Ho=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Bo=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,zo="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(H.source,"]*"),jo="((?:".concat(zo,"\\:)?").concat(zo,")"),Wo=new RegExp("^<".concat(jo)),Go=/^\s*(\/?)>/,Xo=new RegExp("^<\\/".concat(jo,"[^>]*>")),Qo=/^<!DOCTYPE [^>]+>/i,Ko=/^<!\--/,Yo=/^<!\[/,Jo=f("script,style,textarea",!0),Zo={},es={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},ts=/&(?:lt|gt|quot|amp|#39);/g,ns=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,as=f("pre,textarea",!0),is=function(e,t){return e&&as(e)&&"\n"===t[0]};function os(e,t){var n=t?ns:ts;return e.replace(n,(function(e){return es[e]}))}var ss,rs,ps,us,ls,ds,ys,cs,ms=/^@|^v-on:/,fs=/^v-|^@|^:|^#/,hs=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,bs=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Ts=/^\(|\)$/g,vs=/^\[.*\]$/,ws=/:(.*)$/,gs=/^:|^\.|^v-bind:/,ks=/\.[^.\]]+(?=[^\]]*$)/g,Ms=/^v-slot(:|$)|^#/,Is=/[\r\n]/,_s=/[ \f\t\r\n]+/g,xs=g((function(e){return(Fo=Fo||document.createElement("div")).innerHTML=e,Fo.textContent})),Rs="_empty_";function Ss(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:qs(t),rawAttrsMap:{},parent:n,children:[]}}function Cs(e,t){ss=t.warn||Qa,ds=t.isPreTag||E,ys=t.mustUseProp||E,cs=t.getTagNamespace||E;t.isReservedTag;ps=Ka(t.modules,"transformNode"),us=Ka(t.modules,"preTransformNode"),ls=Ka(t.modules,"postTransformNode"),rs=t.delimiters;var n,a,i=[],o=!1!==t.preserveWhitespace,s=t.whitespace,r=!1,p=!1;function u(e){if(l(e),r||e.processed||(e=As(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&Es(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)s=e,u=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),u&&u.if&&Es(u,{exp:s.elseif,block:s});else{if(e.slotScope){var o=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[o]=e}a.children.push(e),e.parent=a}var s,u;e.children=e.children.filter((function(e){return!e.slotScope})),l(e),e.pre&&(r=!1),ds(e.tag)&&(p=!1);for(var d=0;d<ls.length;d++)ls[d](e,t)}function l(e){if(!p)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],o=t.expectHTML,s=t.isUnaryTag||E,r=t.canBeLeftOpenTag||E,p=0,u=function(){if(n=e,a&&Jo(a)){var u=0,y=a.toLowerCase(),c=Zo[y]||(Zo[y]=new RegExp("([\\s\\S]*?)(</"+y+"[^>]*>)","i"));k=e.replace(c,(function(e,n,a){return u=a.length,Jo(y)||"noscript"===y||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),is(y,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),p+=e.length-k.length,e=k,d(y,p-u,p)}else{var m=e.indexOf("<");if(0===m){if(Ko.test(e)){var f=e.indexOf("--\x3e");if(f>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,f),p,p+f+3),l(f+3),"continue"}if(Yo.test(e)){var h=e.indexOf("]>");if(h>=0)return l(h+2),"continue"}var b=e.match(Qo);if(b)return l(b[0].length),"continue";var T=e.match(Xo);if(T){var v=p;return l(T[0].length),d(T[1],v,p),"continue"}var w=function(){var t=e.match(Wo);if(t){var n={tagName:t[1],attrs:[],start:p};l(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Go))&&(i=e.match(Bo)||e.match(Ho));)i.start=p,l(i[0].length),i.end=p,n.attrs.push(i);if(a)return n.unarySlash=a[1],l(a[0].length),n.end=p,n}}();if(w)return function(e){var n=e.tagName,p=e.unarySlash;o&&("p"===a&&$o(n)&&d(a),r(n)&&a===n&&d(n));for(var u=s(n)||!!p,l=e.attrs.length,y=new Array(l),c=0;c<l;c++){var m=e.attrs[c],f=m[3]||m[4]||m[5]||"",h="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;y[c]={name:m[1],value:os(f,h)}}u||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:y,start:e.start,end:e.end}),a=n),t.start&&t.start(n,y,u,e.start,e.end)}(w),is(w.tagName,e)&&l(1),"continue"}var g=void 0,k=void 0,M=void 0;if(m>=0){for(k=e.slice(m);!(Xo.test(k)||Wo.test(k)||Ko.test(k)||Yo.test(k)||(M=k.indexOf("<",1))<0);)m+=M,k=e.slice(m);g=e.substring(0,m)}m<0&&(g=e),g&&l(g.length),t.chars&&g&&t.chars(g,p-g.length,p)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==u(););function l(t){p+=t,e=e.substring(t)}function d(e,n,o){var s,r;if(null==n&&(n=p),null==o&&(o=p),e)for(r=e.toLowerCase(),s=i.length-1;s>=0&&i[s].lowerCasedTag!==r;s--);else s=0;if(s>=0){for(var u=i.length-1;u>=s;u--)t.end&&t.end(i[u].tag,n,o);i.length=s,a=s&&i[s-1].tag}else"br"===r?t.start&&t.start(e,[],!0,n,o):"p"===r&&(t.start&&t.start(e,[],!1,n,o),t.end&&t.end(e,n,o))}d()}(e,{warn:ss,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,o,s,l,d){var y=a&&a.ns||cs(e);Q&&"svg"===y&&(o=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];Us.test(a.name)||(a.name=a.name.replace(Ls,""),t.push(a))}return t}(o));var c,m=Ss(e,o,a);y&&(m.ns=y),"style"!==(c=m).tag&&("script"!==c.tag||c.attrsMap.type&&"text/javascript"!==c.attrsMap.type)||ie()||(m.forbidden=!0);for(var f=0;f<us.length;f++)m=us[f](m,t)||m;r||(function(e){null!=ii(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(r=!0)),ds(m.tag)&&(p=!0),r?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Ps(m),function(e){var t=ii(e,"v-if");if(t)e.if=t,Es(e,{exp:t,block:e});else{null!=ii(e,"v-else")&&(e.else=!0);var n=ii(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=ii(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),s?u(m):(a=m,i.push(m))},end:function(e,t,n){var o=i[i.length-1];i.length-=1,a=i[i.length-1],u(o)},chars:function(e,t,n){if(a&&(!Q||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,u=a.children;if(e=p||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:xs(e):u.length?s?"condense"===s&&Is.test(e)?"":" ":o?" ":"":""){p||"condense"!==s||(e=e.replace(_s," "));var l=void 0,d=void 0;!r&&" "!==e&&(l=function(e,t){var n=t?Uo(t):Oo;if(n.test(e)){for(var a,i,o,s=[],r=[],p=n.lastIndex=0;a=n.exec(e);){(i=a.index)>p&&(r.push(o=e.slice(p,i)),s.push(JSON.stringify(o)));var u=Ga(a[1].trim());s.push("_s(".concat(u,")")),r.push({"@binding":u}),p=i+a[0].length}return p<e.length&&(r.push(o=e.slice(p)),s.push(JSON.stringify(o))),{expression:s.join("+"),tokens:r}}}(e,rs))?d={type:2,expression:l.expression,tokens:l.tokens,text:e}:" "===e&&u.length&&" "===u[u.length-1].text||(d={type:3,text:e}),d&&u.push(d)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function As(e,t){var n;!function(e){var t=ai(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=ai(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ii(e,"scope"),e.slotScope=t||ii(e,"slot-scope")):(t=ii(e,"slot-scope"))&&(e.slotScope=t);var n,a=ai(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Ja(e,"slot",a,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){if(n=oi(e,Ms)){var i=Fs(n),o=i.name,s=i.dynamic;e.slotTarget=o,e.slotTargetDynamic=s,e.slotScope=n.value||Rs}}else if(n=oi(e,Ms)){var r=e.scopedSlots||(e.scopedSlots={}),p=Fs(n),u=p.name,l=(s=p.dynamic,r[u]=Ss("template",[],e));l.slotTarget=u,l.slotTargetDynamic=s,l.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=l,!0})),l.slotScope=n.value||Rs,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=ai(n,"name")),function(e){var t;(t=ai(e,"is"))&&(e.component=t),null!=ii(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<ps.length;a++)e=ps[a](e,t)||e;return function(e){var t,n,a,i,o,s,r,p,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(a=i=u[t].name,o=u[t].value,fs.test(a))if(e.hasBindings=!0,(s=Os(a.replace(fs,"")))&&(a=a.replace(ks,"")),gs.test(a))a=a.replace(gs,""),o=Ga(o),(p=vs.test(a))&&(a=a.slice(1,-1)),s&&(s.prop&&!p&&"innerHtml"===(a=M(a))&&(a="innerHTML"),s.camel&&!p&&(a=M(a)),s.sync&&(r=pi(o,"$event"),p?ni(e,'"update:"+('.concat(a,")"),r,null,!1,0,u[t],!0):(ni(e,"update:".concat(M(a)),r,null,!1,0,u[t]),x(a)!==M(a)&&ni(e,"update:".concat(x(a)),r,null,!1,0,u[t])))),s&&s.prop||!e.component&&ys(e.tag,e.attrsMap.type,a)?Ya(e,a,o,u[t],p):Ja(e,a,o,u[t],p);else if(ms.test(a))a=a.replace(ms,""),(p=vs.test(a))&&(a=a.slice(1,-1)),ni(e,a,o,s,!1,0,u[t],p);else{var l=(a=a.replace(fs,"")).match(ws),d=l&&l[1];p=!1,d&&(a=a.slice(0,-(d.length+1)),vs.test(d)&&(d=d.slice(1,-1),p=!0)),ei(e,a,i,o,d,p,s,u[t])}else Ja(e,a,JSON.stringify(o),u[t]),!e.component&&"muted"===a&&ys(e.tag,e.attrsMap.type,a)&&Ya(e,a,"true",u[t])}(e),e}function Ps(e){var t;if(t=ii(e,"v-for")){var n=function(e){var t=e.match(hs);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(Ts,""),i=a.match(bs);return i?(n.alias=a.replace(bs,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&C(e,n)}}function Es(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Fs(e){var t=e.name.replace(Ms,"");return t||"#"!==e.name[0]&&(t="default"),vs.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function Os(e){var t=e.match(ks);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function qs(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var Us=/^xmlns:NS\d+/,Ls=/^NS\d+:/;function Ds(e){return Ss(e.tag,e.attrsList.slice(),e.parent)}var Ns,Vs,$s=[Lo,Do,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=ai(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=ii(e,"v-if",!0),o=i?"&&(".concat(i,")"):"",s=null!=ii(e,"v-else",!0),r=ii(e,"v-else-if",!0),p=Ds(e);Ps(p),Za(p,"type","checkbox"),As(p,t),p.processed=!0,p.if="(".concat(a,")==='checkbox'")+o,Es(p,{exp:p.if,block:p});var u=Ds(e);ii(u,"v-for",!0),Za(u,"type","radio"),As(u,t),Es(p,{exp:"(".concat(a,")==='radio'")+o,block:u});var l=Ds(e);return ii(l,"v-for",!0),Za(l,":type",a),As(l,t),Es(p,{exp:i,block:l}),s?p.else=!0:r&&(p.elseif=r),p}}}}],Hs={expectHTML:!0,modules:$s,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,o=e.tag,s=e.attrsMap.type;if(e.component)return ri(e,a,i),!1;if("select"===o)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),o="var $$selectedVal = ".concat(i,";");ni(e,"change",o="".concat(o," ").concat(pi(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===o&&"checkbox"===s)!function(e,t,n){var a=n&&n.number,i=ai(e,"value")||"null",o=ai(e,"true-value")||"true",s=ai(e,"false-value")||"false";Ya(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===o?":(".concat(t,")"):":_q(".concat(t,",").concat(o,")"))),ni(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(o,"):(").concat(s,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(pi(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(pi(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(pi(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===o&&"radio"===s)!function(e,t,n){var a=n&&n.number,i=ai(e,"value")||"null";i=a?"_n(".concat(i,")"):i,Ya(e,"checked","_q(".concat(t,",").concat(i,")")),ni(e,"change",pi(t,i),null,!0)}(e,a,i);else if("input"===o||"textarea"===o)!function(e,t,n){var a=e.attrsMap.type,i=n||{},o=i.lazy,s=i.number,r=i.trim,p=!o&&"range"!==a,u=o?"change":"range"===a?"__r":"input",l="$event.target.value";r&&(l="$event.target.value.trim()"),s&&(l="_n(".concat(l,")"));var d=pi(t,l);p&&(d="if($event.target.composing)return;".concat(d)),Ya(e,"value","(".concat(t,")")),ni(e,u,d,null,!0),(r||s)&&ni(e,"blur","$forceUpdate()")}(e,a,i);else if(!$.isReservedTag(o))return ri(e,a,i),!1;return!0},text:function(e,t){t.value&&Ya(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&Ya(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:No,mustUseProp:ea,canBeLeftOpenTag:Vo,isReservedTag:ma,getTagNamespace:fa,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}($s)},Bs=g((function(e){return f("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function zs(e,t){e&&(Ns=Bs(t.staticKeys||""),Vs=t.isReservedTag||E,js(e),Ws(e,!1))}function js(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||h(e.tag)||!Vs(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Ns))))}(e),1===e.type){if(!Vs(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];js(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;js(i),i.static||(e.static=!1)}}}function Ws(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Ws(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Ws(e.ifConditions[n].block,t)}}var Gs=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Xs=/\([^)]*?\);*$/,Qs=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Ks={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Ys={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Js=function(e){return"if(".concat(e,")return null;")},Zs={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Js("$event.target !== $event.currentTarget"),ctrl:Js("!$event.ctrlKey"),shift:Js("!$event.shiftKey"),alt:Js("!$event.altKey"),meta:Js("!$event.metaKey"),left:Js("'button' in $event && $event.button !== 0"),middle:Js("'button' in $event && $event.button !== 1"),right:Js("'button' in $event && $event.button !== 2")};function er(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var o in e){var s=tr(e[o]);e[o]&&e[o].dynamic?i+="".concat(o,",").concat(s,","):a+='"'.concat(o,'":').concat(s,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function tr(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return tr(e)})).join(","),"]");var t=Qs.test(e.value),n=Gs.test(e.value),a=Qs.test(e.value.replace(Xs,""));if(e.modifiers){var i="",o="",s=[],r=function(t){if(Zs[t])o+=Zs[t],Ks[t]&&s.push(t);else if("exact"===t){var n=e.modifiers;o+=Js(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else s.push(t)};for(var p in e.modifiers)r(p);s.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(nr).join("&&"),")return null;")}(s)),o&&(i+=o);var u=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(u,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function nr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=Ks[e],a=Ys[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var ar={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:P},ir=function(e){this.options=e,this.warn=e.warn||Qa,this.transforms=Ka(e.modules,"transformCode"),this.dataGenFns=Ka(e.modules,"genData"),this.directives=C(C({},ar),e.directives);var t=e.isReservedTag||E;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function or(e,t){var n=new ir(t),a=e?"script"===e.tag?"null":sr(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function sr(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return rr(e,t);if(e.once&&!e.onceProcessed)return pr(e,t);if(e.for&&!e.forProcessed)return dr(e,t);if(e.if&&!e.ifProcessed)return ur(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=fr(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),o=e.attrs||e.dynamicAttrs?Tr((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:M(e.name),value:e.value,dynamic:e.dynamic}}))):null,s=e.attrsMap["v-bind"];return!o&&!s||a||(i+=",null"),o&&(i+=",".concat(o)),s&&(i+="".concat(o?"":",null",",").concat(s)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:fr(t,n,!0);return"_c(".concat(e,",").concat(yr(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=yr(e,t));var o=void 0,s=t.options.bindings;i&&s&&!1!==s.__isScriptSetup&&(o=function(e,t){var n=M(t),a=I(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},o=i("setup-const")||i("setup-reactive-const");if(o)return o;var s=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return s||void 0}(s,e.tag)),o||(o="'".concat(e.tag,"'"));var r=e.inlineTemplate?null:fr(e,t,!0);n="_c(".concat(o).concat(a?",".concat(a):"").concat(r?",".concat(r):"",")")}for(var p=0;p<t.transforms.length;p++)n=t.transforms[p](e,n);return n}return fr(e,t)||"void 0"}function rr(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(sr(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function pr(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return ur(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(sr(e,t),",").concat(t.onceId++,",").concat(n,")"):sr(e,t)}return rr(e,t)}function ur(e,t,n,a){return e.ifProcessed=!0,lr(e.ifConditions.slice(),t,n,a)}function lr(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(o(i.block),":").concat(lr(e,t,n,a)):"".concat(o(i.block));function o(e){return n?n(e,t):e.once?pr(e,t):sr(e,t)}}function dr(e,t,n,a){var i=e.for,o=e.alias,s=e.iterator1?",".concat(e.iterator1):"",r=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(o).concat(s).concat(r,"){")+"return ".concat((n||sr)(e,t))+"})"}function yr(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,o,s,r="directives:[",p=!1;for(a=0,i=n.length;a<i;a++){o=n[a],s=!0;var u=t.directives[o.name];u&&(s=!!u(e,o,t.warn)),s&&(p=!0,r+='{name:"'.concat(o.name,'",rawName:"').concat(o.rawName,'"').concat(o.value?",value:(".concat(o.value,"),expression:").concat(JSON.stringify(o.value)):"").concat(o.arg?",arg:".concat(o.isDynamicArg?o.arg:'"'.concat(o.arg,'"')):"").concat(o.modifiers?",modifiers:".concat(JSON.stringify(o.modifiers)):"","},"))}return p?r.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(Tr(e.attrs),",")),e.props&&(n+="domProps:".concat(Tr(e.props),",")),e.events&&(n+="".concat(er(e.events,!1),",")),e.nativeEvents&&(n+="".concat(er(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||cr(n)})),i=!!e.if;if(!a)for(var o=e.parent;o;){if(o.slotScope&&o.slotScope!==Rs||o.for){a=!0;break}o.if&&(i=!0),o=o.parent}var s=Object.keys(t).map((function(e){return mr(t[e],n)})).join(",");return"scopedSlots:_u([".concat(s,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(s)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var o=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=or(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);o&&(n+="".concat(o,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(Tr(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function cr(e){return 1===e.type&&("slot"===e.tag||e.children.some(cr))}function mr(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return ur(e,t,mr,"null");if(e.for&&!e.forProcessed)return dr(e,t,mr);var a=e.slotScope===Rs?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(fr(e,t)||"undefined",":undefined"):fr(e,t)||"undefined":sr(e,t),"}"),o=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(o,"}")}function fr(e,t,n,a,i){var o=e.children;if(o.length){var s=o[0];if(1===o.length&&s.for&&"template"!==s.tag&&"slot"!==s.tag){var r=n?t.maybeComponent(s)?",1":",0":"";return"".concat((a||sr)(s,t)).concat(r)}var p=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(hr(i)||i.ifConditions&&i.ifConditions.some((function(e){return hr(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(o,t.maybeComponent):0,u=i||br;return"[".concat(o.map((function(e){return u(e,t)})).join(","),"]").concat(p?",".concat(p):"")}}function hr(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function br(e,t){return 1===e.type?sr(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:vr(JSON.stringify(n.text)),")");var n}function Tr(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],o=vr(i.value);i.dynamic?n+="".concat(i.name,",").concat(o,","):t+='"'.concat(i.name,'":').concat(o,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function vr(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function wr(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),P}}function gr(e){var t=Object.create(null);return function(n,a,i){(a=C({},a)).warn,delete a.warn;var o=a.delimiters?String(a.delimiters)+n:n;if(t[o])return t[o];var s=e(n,a),r={},p=[];return r.render=wr(s.render,p),r.staticRenderFns=s.staticRenderFns.map((function(e){return wr(e,p)})),t[o]=r}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var kr,Mr,Ir=(kr=function(e,t){var n=Cs(e.trim(),t);!1!==t.optimize&&zs(n,t);var a=or(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],o=[];if(n)for(var s in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=C(Object.create(e.directives||null),n.directives)),n)"modules"!==s&&"directives"!==s&&(a[s]=n[s]);a.warn=function(e,t,n){(n?o:i).push(e)};var r=kr(t.trim(),a);return r.errors=i,r.tips=o,r}return{compile:t,compileToFunctions:gr(t)}}),_r=Ir(Hs).compileToFunctions;function xr(e){return(Mr=Mr||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Mr.innerHTML.indexOf("&#10;")>0}var Rr=!!G&&xr(!1),Sr=!!G&&xr(!0),Cr=g((function(e){var t=Ta(e);return t&&t.innerHTML})),Ar=jn.prototype.$mount;function Pr(e,t){for(var n in t)e[n]=t[n];return e}jn.prototype.$mount=function(e,t){if((e=e&&Ta(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Cr(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=_r(a,{outputSourceRange:!1,shouldDecodeNewlines:Rr,shouldDecodeNewlinesForHref:Sr,delimiters:n.delimiters,comments:n.comments},this),o=i.render,s=i.staticRenderFns;n.render=o,n.staticRenderFns=s}}return Ar.call(this,e,t)},jn.compile=_r;var Er=/[!'()*]/g,Fr=function(e){return"%"+e.charCodeAt(0).toString(16)},Or=/%2C/g,qr=function(e){return encodeURIComponent(e).replace(Er,Fr).replace(Or,",")};function Ur(e){try{return decodeURIComponent(e)}catch(e){}return e}var Lr=function(e){return null==e||"object"==typeof e?e:String(e)};function Dr(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Ur(n.shift()),i=n.length>0?Ur(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Nr(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return qr(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(qr(t)):a.push(qr(t)+"="+qr(e)))})),a.join("&")}return qr(t)+"="+qr(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Vr=/\/?$/;function $r(e,t,n,a){var i=a&&a.options.stringifyQuery,o=t.query||{};try{o=Hr(o)}catch(e){}var s={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:o,params:t.params||{},fullPath:jr(t,i),matched:e?zr(e):[]};return n&&(s.redirectedFrom=jr(n,i)),Object.freeze(s)}function Hr(e){if(Array.isArray(e))return e.map(Hr);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Hr(e[n]);return t}return e}var Br=$r(null,{path:"/"});function zr(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function jr(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Nr)(a)+i}function Wr(e,t,n){return t===Br?e===t:!!t&&(e.path&&t.path?e.path.replace(Vr,"")===t.path.replace(Vr,"")&&(n||e.hash===t.hash&&Gr(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Gr(e.query,t.query)&&Gr(e.params,t.params)))}function Gr(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var o=e[n];if(a[i]!==n)return!1;var s=t[n];return null==o||null==s?o===s:"object"==typeof o&&"object"==typeof s?Gr(o,s):String(o)===String(s)}))}function Xr(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],o=n.enteredCbs[a];if(i&&o){delete n.enteredCbs[a];for(var s=0;s<o.length;s++)i._isBeingDestroyed||o[s](i)}}}}var Qr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,o=t.data;o.routerView=!0;for(var s=i.$createElement,r=n.name,p=i.$route,u=i._routerViewCache||(i._routerViewCache={}),l=0,d=!1;i&&i._routerRoot!==i;){var y=i.$vnode?i.$vnode.data:{};y.routerView&&l++,y.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(o.routerViewDepth=l,d){var c=u[r],m=c&&c.component;return m?(c.configProps&&Kr(m,o,c.route,c.configProps),s(m,o,a)):s()}var f=p.matched[l],h=f&&f.components[r];if(!f||!h)return u[r]=null,s();u[r]={component:h},o.registerRouteInstance=function(e,t){var n=f.instances[r];(t&&n!==e||!t&&n===e)&&(f.instances[r]=t)},(o.hook||(o.hook={})).prepatch=function(e,t){f.instances[r]=t.componentInstance},o.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[r]&&(f.instances[r]=e.componentInstance),Xr(p)};var b=f.props&&f.props[r];return b&&(Pr(u[r],{route:p,configProps:b}),Kr(h,o,p,b)),s(h,o,a)}};function Kr(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=Pr({},i);var o=t.attrs=t.attrs||{};for(var s in i)e.props&&s in e.props||(o[s]=i[s],delete i[s])}}function Yr(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var o=e.replace(/^\//,"").split("/"),s=0;s<o.length;s++){var r=o[s];".."===r?i.pop():"."!==r&&i.push(r)}return""!==i[0]&&i.unshift(""),i.join("/")}function Jr(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var Zr=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},ep=function e(t,n,a){return Zr(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return dp(e,t)}(t,n):Zr(t)?function(t,n,a){for(var i=[],o=0;o<t.length;o++)i.push(e(t[o],n,a).source);return dp(new RegExp("(?:"+i.join("|")+")",yp(a)),n)}(t,n,a):function(e,t,n){return cp(op(e,n),t,n)}(t,n,a)},tp=op,np=pp,ap=cp,ip=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function op(e,t){for(var n,a=[],i=0,o=0,s="",r=t&&t.delimiter||"/";null!=(n=ip.exec(e));){var p=n[0],u=n[1],l=n.index;if(s+=e.slice(o,l),o=l+p.length,u)s+=u[1];else{var d=e[o],y=n[2],c=n[3],m=n[4],f=n[5],h=n[6],b=n[7];s&&(a.push(s),s="");var T=null!=y&&null!=d&&d!==y,v="+"===h||"*"===h,w="?"===h||"*"===h,g=n[2]||r,k=m||f;a.push({name:c||i++,prefix:y||"",delimiter:g,optional:w,repeat:v,partial:T,asterisk:!!b,pattern:k?lp(k):b?".*":"[^"+up(g)+"]+?"})}}return o<e.length&&(s+=e.substr(o)),s&&a.push(s),a}function sp(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function rp(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function pp(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",yp(t)));return function(t,a){for(var i="",o=t||{},s=(a||{}).pretty?sp:encodeURIComponent,r=0;r<e.length;r++){var p=e[r];if("string"!=typeof p){var u,l=o[p.name];if(null==l){if(p.optional){p.partial&&(i+=p.prefix);continue}throw new TypeError('Expected "'+p.name+'" to be defined')}if(Zr(l)){if(!p.repeat)throw new TypeError('Expected "'+p.name+'" to not repeat, but received `'+JSON.stringify(l)+"`");if(0===l.length){if(p.optional)continue;throw new TypeError('Expected "'+p.name+'" to not be empty')}for(var d=0;d<l.length;d++){if(u=s(l[d]),!n[r].test(u))throw new TypeError('Expected all "'+p.name+'" to match "'+p.pattern+'", but received `'+JSON.stringify(u)+"`");i+=(0===d?p.prefix:p.delimiter)+u}}else{if(u=p.asterisk?rp(l):s(l),!n[r].test(u))throw new TypeError('Expected "'+p.name+'" to match "'+p.pattern+'", but received "'+u+'"');i+=p.prefix+u}}else i+=p}return i}}function up(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function lp(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function dp(e,t){return e.keys=t,e}function yp(e){return e&&e.sensitive?"":"i"}function cp(e,t,n){Zr(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,o="",s=0;s<e.length;s++){var r=e[s];if("string"==typeof r)o+=up(r);else{var p=up(r.prefix),u="(?:"+r.pattern+")";t.push(r),r.repeat&&(u+="(?:"+p+u+")*"),o+=u=r.optional?r.partial?p+"("+u+")?":"(?:"+p+"("+u+"))?":p+"("+u+")"}}var l=up(n.delimiter||"/"),d=o.slice(-l.length)===l;return a||(o=(d?o.slice(0,-l.length):o)+"(?:"+l+"(?=$))?"),o+=i?"$":a&&d?"":"(?="+l+"|$)",dp(new RegExp("^"+o,yp(n)),t)}ep.parse=tp,ep.compile=function(e,t){return pp(op(e,t),t)},ep.tokensToFunction=np,ep.tokensToRegExp=ap;var mp=Object.create(null);function fp(e,t,n){t=t||{};try{var a=mp[e]||(mp[e]=ep.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function hp(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var o=(i=Pr({},e)).params;return o&&"object"==typeof o&&(i.params=Pr({},o)),i}if(!i.path&&i.params&&t){(i=Pr({},i))._normalized=!0;var s=Pr(Pr({},t.params),i.params);if(t.name)i.name=t.name,i.params=s;else if(t.matched.length){var r=t.matched[t.matched.length-1].path;i.path=fp(r,s,t.path)}return i}var p=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),u=t&&t.path||"/",l=p.path?Yr(p.path,u,n||i.append):u,d=function(e,t,n){void 0===t&&(t={});var a,i=n||Dr;try{a=i(e||"")}catch(e){a={}}for(var o in t){var s=t[o];a[o]=Array.isArray(s)?s.map(Lr):Lr(s)}return a}(p.query,i.query,a&&a.options.parseQuery),y=i.hash||p.hash;return y&&"#"!==y.charAt(0)&&(y="#"+y),{_normalized:!0,path:l,query:d,hash:y}}var bp,Tp=function(){},vp={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),o=i.location,s=i.route,r=i.href,p={},u=n.options.linkActiveClass,l=n.options.linkExactActiveClass,d=null==u?"router-link-active":u,y=null==l?"router-link-exact-active":l,c=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?y:this.exactActiveClass,f=s.redirectedFrom?$r(null,hp(s.redirectedFrom),null,n):s;p[m]=Wr(a,f,this.exactPath),p[c]=this.exact||this.exactPath?p[m]:function(e,t){return 0===e.path.replace(Vr,"/").indexOf(t.path.replace(Vr,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var h=p[m]?this.ariaCurrentValue:null,b=function(e){wp(e)&&(t.replace?n.replace(o,Tp):n.push(o,Tp))},T={click:wp};Array.isArray(this.event)?this.event.forEach((function(e){T[e]=b})):T[this.event]=b;var v={class:p},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:r,route:s,navigate:b,isActive:p[c],isExactActive:p[m]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?e():e("span",{},w)}if("a"===this.tag)v.on=T,v.attrs={href:r,"aria-current":h};else{var g=gp(this.$slots.default);if(g){g.isStatic=!1;var k=g.data=Pr({},g.data);for(var M in k.on=k.on||{},k.on){var I=k.on[M];M in T&&(k.on[M]=Array.isArray(I)?I:[I])}for(var _ in T)_ in k.on?k.on[_].push(T[_]):k.on[_]=b;var x=g.data.attrs=Pr({},g.data.attrs);x.href=r,x["aria-current"]=h}else v.on=T}return e(this.tag,v,this.$slots.default)}};function wp(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function gp(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=gp(t.children)))return t}}var kp="undefined"!=typeof window;function Mp(e,t,n,a,i){var o=t||[],s=n||Object.create(null),r=a||Object.create(null);e.forEach((function(e){Ip(o,s,r,e,i)}));for(var p=0,u=o.length;p<u;p++)"*"===o[p]&&(o.push(o.splice(p,1)[0]),u--,p--);return{pathList:o,pathMap:s,nameMap:r}}function Ip(e,t,n,a,i,o){var s=a.path,r=a.name,p=a.pathToRegexpOptions||{},u=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:Jr(t.path+"/"+e)}(s,i,p.strict);"boolean"==typeof a.caseSensitive&&(p.sensitive=a.caseSensitive);var l={path:u,regex:_p(u,p),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:r,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=o?Jr(o+"/"+a.path):void 0;Ip(e,t,n,a,l,i)})),t[l.path]||(e.push(l.path),t[l.path]=l),void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],y=0;y<d.length;++y){var c={path:d[y],children:a.children};Ip(e,t,n,c,i,l.path||"/")}r&&(n[r]||(n[r]=l))}function _p(e,t){return ep(e,[],t)}function xp(e,t){var n=Mp(e),a=n.pathList,i=n.pathMap,o=n.nameMap;function s(e,n,s){var p=hp(e,n,!1,t),u=p.name;if(u){var l=o[u];if(!l)return r(null,p);var d=l.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof p.params&&(p.params={}),n&&"object"==typeof n.params)for(var y in n.params)!(y in p.params)&&d.indexOf(y)>-1&&(p.params[y]=n.params[y]);return p.path=fp(l.path,p.params),r(l,p,s)}if(p.path){p.params={};for(var c=0;c<a.length;c++){var m=a[c],f=i[m];if(Rp(f.regex,p.path,p.params))return r(f,p,s)}}return r(null,p)}function r(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a($r(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return r(null,n);var p=i,u=p.name,l=p.path,d=n.query,y=n.hash,c=n.params;if(d=p.hasOwnProperty("query")?p.query:d,y=p.hasOwnProperty("hash")?p.hash:y,c=p.hasOwnProperty("params")?p.params:c,u)return o[u],s({_normalized:!0,name:u,query:d,hash:y,params:c},void 0,n);if(l){var m=function(e,t){return Yr(e,t.parent?t.parent.path:"/",!0)}(l,e);return s({_normalized:!0,path:fp(m,c),query:d,hash:y},void 0,n)}return r(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=s({_normalized:!0,path:fp(n,t.params)});if(a){var i=a.matched,o=i[i.length-1];return t.params=a.params,r(o,t)}return r(null,t)}(0,n,e.matchAs):$r(e,n,a,t)}return{match:s,addRoute:function(e,t){var n="object"!=typeof e?o[e]:void 0;Mp([t||e],a,i,o,n),n&&n.alias.length&&Mp(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,o,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){Mp(e,a,i,o)}}}function Rp(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,o=a.length;i<o;++i){var s=e.keys[i-1];s&&(n[s.name||"pathMatch"]="string"==typeof a[i]?Ur(a[i]):a[i])}return!0}var Sp=kp&&window.performance&&window.performance.now?window.performance:Date;function Cp(){return Sp.now().toFixed(3)}var Ap=Cp();function Pp(){return Ap}function Ep(e){return Ap=e}var Fp=Object.create(null);function Op(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=Pr({},window.history.state);return n.key=Pp(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Lp),function(){window.removeEventListener("popstate",Lp)}}function qp(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var o=function(){var e=Pp();if(e)return Fp[e]}(),s=i.call(e,t,n,a?o:null);s&&("function"==typeof s.then?s.then((function(e){Hp(e,o)})).catch((function(e){})):Hp(s,o))}))}}function Up(){var e=Pp();e&&(Fp[e]={x:window.pageXOffset,y:window.pageYOffset})}function Lp(e){Up(),e.state&&e.state.key&&Ep(e.state.key)}function Dp(e){return Vp(e.x)||Vp(e.y)}function Np(e){return{x:Vp(e.x)?e.x:window.pageXOffset,y:Vp(e.y)?e.y:window.pageYOffset}}function Vp(e){return"number"==typeof e}var $p=/^#\d/;function Hp(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=$p.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var o=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,o={x:Vp((n=o).x)?n.x:0,y:Vp(n.y)?n.y:0})}else Dp(e)&&(t=Np(e))}else a&&Dp(e)&&(t=Np(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Bp,zp=kp&&(-1===(Bp=window.navigator.userAgent).indexOf("Android 2.")&&-1===Bp.indexOf("Android 4.0")||-1===Bp.indexOf("Mobile Safari")||-1!==Bp.indexOf("Chrome")||-1!==Bp.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function jp(e,t){Up();var n=window.history;try{if(t){var a=Pr({},n.state);a.key=Pp(),n.replaceState(a,"",e)}else n.pushState({key:Ep(Cp())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Wp(e){jp(e,!0)}var Gp={redirected:2,aborted:4,cancelled:8,duplicated:16};function Xp(e,t){return Qp(e,t,Gp.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Qp(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var Kp=["params","query","hash"];function Yp(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Jp(e,t){return Yp(e)&&e._isRouter&&(null==t||e.type===t)}function Zp(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function eu(e,t){return tu(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function tu(e){return Array.prototype.concat.apply([],e)}var nu="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function au(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var iu=function(e,t){this.router=e,this.base=function(e){if(!e)if(kp){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Br,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ou(e,t,n,a){var i=eu(e,(function(e,a,i,o){var s=function(e,t){return"function"!=typeof e&&(e=bp.extend(e)),e.options[t]}(e,t);if(s)return Array.isArray(s)?s.map((function(e){return n(e,a,i,o)})):n(s,a,i,o)}));return tu(a?i.reverse():i)}function su(e,t){if(t)return function(){return e.apply(t,arguments)}}iu.prototype.listen=function(e){this.cb=e},iu.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},iu.prototype.onError=function(e){this.errorCbs.push(e)},iu.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var o=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(Jp(e,Gp.redirected)&&o===Br||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},iu.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var o,s,r=function(e){!Jp(e)&&Yp(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},p=e.matched.length-1,u=i.matched.length-1;if(Wr(e,i)&&p===u&&e.matched[p]===i.matched[u])return this.ensureURL(),e.hash&&qp(this.router,i,e,!1),r(((s=Qp(o=i,e,Gp.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",s));var l,d=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),y=d.updated,c=d.deactivated,m=d.activated,f=[].concat(function(e){return ou(e,"beforeRouteLeave",su,!0)}(c),this.router.beforeHooks,function(e){return ou(e,"beforeRouteUpdate",su)}(y),m.map((function(e){return e.beforeEnter})),(l=m,function(e,t,n){var a=!1,i=0,o=null;eu(l,(function(e,t,s,r){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var p,u=au((function(t){var a;((a=t).__esModule||nu&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:bp.extend(t),s.components[r]=t,--i<=0&&n()})),l=au((function(e){var t="Failed to resolve async component "+r+": "+e;o||(o=Yp(e)?e:new Error(t),n(o))}));try{p=e(u,l)}catch(e){l(e)}if(p)if("function"==typeof p.then)p.then(u,l);else{var d=p.component;d&&"function"==typeof d.then&&d.then(u,l)}}})),a||n()})),h=function(t,n){if(a.pending!==e)return r(Xp(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),r(function(e,t){return Qp(e,t,Gp.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Yp(t)?(a.ensureURL(!0),r(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(r(function(e,t){return Qp(e,t,Gp.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return Kp.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){r(e)}};Zp(f,h,(function(){var n=function(e){return ou(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,o){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),o(e)}))}}(e,n,a)}))}(m);Zp(n.concat(a.router.resolveHooks),h,(function(){if(a.pending!==e)return r(Xp(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Xr(e)}))}))}))},iu.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},iu.prototype.setupListeners=function(){},iu.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Br,this.pending=null};var ru=function(e){function t(t,n){e.call(this,t,n),this._startLocation=pu(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=zp&&n;a&&this.listeners.push(Op());var i=function(){var n=e.current,i=pu(e.base);e.current===Br&&i===e._startLocation||e.transitionTo(i,(function(e){a&&qp(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){jp(Jr(a.base+e.fullPath)),qp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Wp(Jr(a.base+e.fullPath)),qp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(pu(this.base)!==this.current.fullPath){var t=Jr(this.base+this.current.fullPath);e?jp(t):Wp(t)}},t.prototype.getCurrentLocation=function(){return pu(this.base)},t}(iu);function pu(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(Jr(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var uu=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=pu(e);if(!/^\/#/.test(t))return window.location.replace(Jr(e+"/#"+t)),!0}(this.base)||lu()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=zp&&t;n&&this.listeners.push(Op());var a=function(){var t=e.current;lu()&&e.transitionTo(du(),(function(a){n&&qp(e.router,a,t,!0),zp||mu(a.fullPath)}))},i=zp?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){cu(e.fullPath),qp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){mu(e.fullPath),qp(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;du()!==t&&(e?cu(t):mu(t))},t.prototype.getCurrentLocation=function(){return du()},t}(iu);function lu(){var e=du();return"/"===e.charAt(0)||(mu("/"+e),!1)}function du(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function yu(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function cu(e){zp?jp(yu(e)):window.location.hash=e}function mu(e){zp?Wp(yu(e)):window.location.replace(yu(e))}var fu=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){Jp(e,Gp.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(iu),hu=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=xp(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!zp&&!1!==e.fallback,this.fallback&&(t="hash"),kp||(t="abstract"),this.mode=t,t){case"history":this.history=new ru(this,e.base);break;case"hash":this.history=new uu(this,e.base,this.fallback);break;case"abstract":this.history=new fu(this,e.base)}},bu={currentRoute:{configurable:!0}};hu.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},bu.currentRoute.get=function(){return this.history&&this.history.current},hu.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof ru||n instanceof uu){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;zp&&i&&"fullPath"in e&&qp(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},hu.prototype.beforeEach=function(e){return vu(this.beforeHooks,e)},hu.prototype.beforeResolve=function(e){return vu(this.resolveHooks,e)},hu.prototype.afterEach=function(e){return vu(this.afterHooks,e)},hu.prototype.onReady=function(e,t){this.history.onReady(e,t)},hu.prototype.onError=function(e){this.history.onError(e)},hu.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},hu.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},hu.prototype.go=function(e){this.history.go(e)},hu.prototype.back=function(){this.go(-1)},hu.prototype.forward=function(){this.go(1)},hu.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},hu.prototype.resolve=function(e,t,n){var a=hp(e,t=t||this.history.current,n,this),i=this.match(a,t),o=i.redirectedFrom||i.fullPath,s=function(e,t,n){var a="hash"===n?"#"+t:t;return e?Jr(e+"/"+a):a}(this.history.base,o,this.mode);return{location:a,route:i,href:s,normalizedTo:a,resolved:i}},hu.prototype.getRoutes=function(){return this.matcher.getRoutes()},hu.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Br&&this.history.transitionTo(this.history.getCurrentLocation())},hu.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Br&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(hu.prototype,bu);var Tu=hu;function vu(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}hu.install=function e(t){if(!e.installed||bp!==t){e.installed=!0,bp=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Qr),t.component("RouterLink",vp);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},hu.version="3.6.5",hu.isNavigationFailure=Jp,hu.NavigationFailureType=Gp,hu.START_LOCATION=Br,kp&&window.Vue&&window.Vue.use(hu);var wu=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function gu(e,t,n,a,i,o,s,r){var p,u="function"==typeof e?e.options:e;if(t&&(u.render=t,u.staticRenderFns=n,u._compiled=!0),a&&(u.functional=!0),o&&(u._scopeId="data-v-"+o),s?(p=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(s)},u._ssrRegister=p):i&&(p=r?function(){i.call(this,(u.functional?this.parent:this).$root.$options.shadowRoot)}:i),p)if(u.functional){u._injectStyles=p;var l=u.render;u.render=function(e,t){return p.call(t),l(e,t)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,p):[p]}return{exports:e,options:u}}wu._withStripped=!0,n(838);const ku=gu({},wu,[],!1,null,null,null).exports;var Mu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};Mu._withStripped=!0;var Iu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Iu._withStripped=!0;const _u=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),xu=gu({data:function(){return{repository:_u.cj,name:_u.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Iu,[],!1,null,null,null).exports;var Ru=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};Ru._withStripped=!0;const Su=gu({},Ru,[],!1,null,null,null).exports;var Cu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Cu._withStripped=!0;var Au=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Au._withStripped=!0;const Pu={components:{MemberSection:gu({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Au,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Eu=gu(Pu,Cu,[],!1,null,null,null).exports;var Fu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};Fu._withStripped=!0;var Ou=gu({components:{Member:Eu},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Fu,[],!1,null,null,null);const qu=gu({components:{Member:Eu,MemberSet:Ou.exports,HeaderBar:Su,FooterBar:xu},props:{json:{type:Object,default:()=>new Object}}},Mu,[],!1,null,null,null).exports;var Uu=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};Uu._withStripped=!0;var Lu=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Lu._withStripped=!0;var Du=gu({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Lu,[],!1,null,null,null);const Nu=gu({components:{Branch:Du.exports,FooterBar:xu},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Uu,[],!1,null,null,null).exports;jn.use(Tu);const Vu={"contracts/DefiEdgeStrategy.sol:DefiEdgeStrategy":{source:"contracts/DefiEdgeStrategy.sol",name:"DefiEdgeStrategy",constructor:{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_oneInchRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract IStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_usdAsBase",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Burn(address,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"share",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"Hold()":{anonymous:!1,inputs:[],name:"Hold",type:"event"},"Mint(address,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"share",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event"},"PartialRebalance((uint256,bool,uint256,uint256)[])":{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],indexed:!1,internalType:"struct DefiEdgeStrategy.PartialTick[]",name:"ticks",type:"tuple[]"}],name:"PartialRebalance",type:"event"},"Rebalance((int24,int24,uint256,uint256)[])":{anonymous:!1,inputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],indexed:!1,internalType:"struct DefiEdgeStrategy.NewTick[]",name:"ticks",type:"tuple[]"}],name:"Rebalance",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accPerformanceFeeShares()":{inputs:[],name:"accPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accProtocolPerformanceFeeShares()":{inputs:[],name:"accProtocolPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_shares",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"}],name:"burn",outputs:[{internalType:"uint256",name:"collect0",type:"uint256"},{internalType:"uint256",name:"collect1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_amount0Min:"Mimimum amount of token0 to be received",_amount1Min:"Minimum amount of token1 to be received",_shares:"Shares to be burned"},returns:{collect0:"The amount of token0 returned to the user",collect1:"The amount of token1 returned to the user"},notice:"Burn liquidity and transfer tokens back to the user"},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},returns:{amount0:"Amount of token0's liquidity burned",amount1:"Amount of token1's liquidity burned",fee0:"Fee of token0 accumulated in the position which is being burned",fee1:"Fee of token1 accumulated in the position which is being burned"},notice:"Burn liquidity from specific tick"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"emergencyWithdraw(address,address,uint256,(int24,int24,uint256,uint256)[])":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgeStrategy.NewTick[]",name:"_newTicks",type:"tuple[]"}],name:"emergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"only governance can withdraw the funds, it can be frozen from the factory permenently",params:{_amount:"Amount to be withdrawn",_newTicks:"Ticks data to burn liquidity from",_to:"Where to transfer the token",_token:"Token to transfer"},notice:"Withdraws funds from the contract in case of emergency"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAUMWithFees(bool)":{inputs:[{internalType:"bool",name:"_includeFee",type:"bool"}],name:"getAUMWithFees",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"totalFee0",type:"uint256"},{internalType:"uint256",name:"totalFee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_includeFee:"Whether to include pool fees in AUM or not. (passing true will also collect fees from pool)",amount0:"Total AUM of token0 including the fees  ( if _includeFee is passed true)",amount1:"Total AUM of token1 including the fees  ( if _includeFee is passed true)",totalFee0:"Total fee of token0 including the fees  ( if _includeFee is passed true)",totalFee1:"Total fee of token1 including the fees  ( if _includeFee is passed true)"},notice:"Get's assets under management with realtime fees"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Array of the ticks"},notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract IStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"mint(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"},{internalType:"uint256",name:"_minShare",type:"uint256"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_amount0:"Amount of token0",_amount0Min:"Minimum amount of token0 to be minted",_amount1:"Amount of token1",_amount1Min:"Minimum amount of token1 to be minted",_minShare:"Minimum amount of shares to be received to the user"},returns:{amount0:"Amount of token0 deployed",amount1:"Amount of token1 deployed",share:"Number of shares minted"},notice:"Adds liquidity to the primary range"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"rebalance(bytes,(uint256,bool,uint256,uint256)[],(int24,int24,uint256,uint256)[],bool)":{inputs:[{internalType:"bytes",name:"_swapData",type:"bytes"},{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgeStrategy.PartialTick[]",name:"_existingTicks",type:"tuple[]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgeStrategy.NewTick[]",name:"_newTicks",type:"tuple[]"},{internalType:"bool",name:"_burnAll",type:"bool"}],name:"rebalance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_burnAll:"When burning into new ticks, should we burn all liquidity?",_existingTicks:"Array of existing ticks to rebalance",_newTicks:"New ticks in case there are any",_swapData:"Swap data to perform exchange from 1inch"},notice:"Rebalances the strategy"},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"total supply of shares, including virtual supply"},notice:"Adds all the shares stored in the state variables"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"usdAsBase(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"usdAsBase",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/DefiEdgeStrategyDeployer.sol:DefiEdgeStrategyDeployer":{source:"contracts/DefiEdgeStrategyDeployer.sol",name:"DefiEdgeStrategyDeployer",title:"DefiEdge Strategy Deployer",notice:"The contract seperately deploys the strategy contracts and factory connects it with manager",events:{"StrategyDeployed(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyDeployed",type:"event"}},methods:{"createStrategy(address,address,address,address,address,bool[2],(int24,int24)[])":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_swapRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract IStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_usdAsBase",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],name:"createStrategy",outputs:[{internalType:"address",name:"strategy",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/DefiEdgeStrategyFactory.sol:DefiEdgeStrategyFactory":{source:"contracts/DefiEdgeStrategyFactory.sol",name:"DefiEdgeStrategyFactory",title:"DefiEdge Strategy Factory",author:"DefiEdge Team",details:"Deployer deploys the straegy and this contract connects it with manager contract",notice:"A factory contract used to launch strategie's to manage assets on Uniswap V3",constructor:{inputs:[{internalType:"address",name:"_governance",type:"address"},{internalType:"contract IDefiEdgeStrategyDeployer",name:"_deployerProxy",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract IUniswapV3Factory",name:"_uniswapV3factory",type:"address"},{internalType:"contract IOneInchRouter",name:"_oneInchRouter",type:"address"},{internalType:"uint256",name:"_allowedSlippage",type:"uint256"},{internalType:"uint256",name:"_allowedDeviation",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},events:{"ChangeAllowedDeviation(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedDeviation",type:"event"},"ChangeAllowedSlippage(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedSlippage",type:"event"},"ChangeAllowedSwapDeviation(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedSwapDeviation",type:"event"},"ChangeDeviation(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"deviation",type:"uint256"}],name:"ChangeDeviation",type:"event"},"ChangeProtocolFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolFee",type:"event"},"ChangeProtocolPerformanceFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolPerformanceFee",type:"event"},"ChangeSlippage(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"slippage",type:"uint256"}],name:"ChangeSlippage",type:"event"},"ChangeStrategyCreationFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ChangeStrategyCreationFee",type:"event"},"ClaimFees(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ClaimFees",type:"event"},"EmergencyFrozen()":{anonymous:!1,inputs:[],name:"EmergencyFrozen",type:"event"},"NewStrategy(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!0,internalType:"address",name:"creater",type:"address"}],name:"NewStrategy",type:"event"},"StrategyStatusChanged(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyStatusChanged",type:"event"}},methods:{"MAX_DECIMAL()":{inputs:[],name:"MAX_DECIMAL",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_PROTOCOL_PERFORMANCE_FEES_RATE()":{inputs:[],name:"MAX_PROTOCOL_PERFORMANCE_FEES_RATE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acceptGovernance()":{inputs:[],name:"acceptGovernance",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Change the governance"},"allowedDeviation(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_pool:"Address of the pool"},returns:{_0:"Default value of for the allowed deviation."},notice:"Current allowed deviation, if specific to pool is defiened it'll return it otherwise returns the default value"},"allowedSlippage(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_pool:"Address of the pool"},returns:{_0:"Current allowed slippage"},notice:"Current allowed slippage if the slippage for specific pool is not defined it'll return default allowed slippage"},"allowedSwapDeviation(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_pool:"Address of the pool"},returns:{_0:"Current allowed swap deviation"},notice:"Current allowed swap deviation by pool, if by pool is not defiened it'll return the default vallue"},"chainlinkRegistry()":{inputs:[],name:"chainlinkRegistry",outputs:[{internalType:"contract FeedRegistryInterface",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeAllowedDeviation(address,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint256",name:"_allowedDeviation",type:"uint256"}],name:"changeAllowedDeviation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allowedDeviation:"New allowed deviation",_pool:"Address of the pool"},notice:"Changes allowed deviation, it is used to check deviation against the pool"},"changeAllowedSlippage(address,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint256",name:"_allowedSlippage",type:"uint256"}],name:"changeAllowedSlippage",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allowedSlippage:"New allowed slippage specific to the pool",_pool:"Address of the pool"},notice:"Changes allowed slippage for specific pool"},"changeAllowedSwapDeviation(address,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint256",name:"_allowedSwapDeviation",type:"uint256"}],name:"changeAllowedSwapDeviation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allowedSwapDeviation:"New allowed swap deviation value",_pool:"Address of the new pool"},notice:"Change allowed swap deviation"},"changeDefaultValues(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_allowedSlippage",type:"uint256"},{internalType:"uint256",name:"_allowedDeviation",type:"uint256"},{internalType:"uint256",name:"_allowedSwapDeviation",type:"uint256"}],name:"changeDefaultValues",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allowedDeviation:"New Default allowed deviation",_allowedSlippage:"New default allowed slippage",_allowedSwapDeviation:"New default allowed deviation for the swap."},notice:"Changes default values for the slippage and deviation"},"changeFeeForStrategyCreation(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeFeeForStrategyCreation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fee:"New fee in 1e18 format"},notice:"Changes strategy creation fees"},"changeFeeTo(address)":{inputs:[{internalType:"address",name:"_feeTo",type:"address"}],name:"changeFeeTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{_feeTo:"New fee to address"},notice:"Change feeTo address"},"changeGovernance(address)":{inputs:[{internalType:"address",name:"_governance",type:"address"}],name:"changeGovernance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_governance:"Address of the new governance"},notice:"Change the governance address"},"changeProtocolFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeProtocolFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fee:"New fee in 1e8 format"},notice:"Changes protocol fees"},"changeProtocolPerformanceFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_feeRate",type:"uint256"}],name:"changeProtocolPerformanceFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_feeRate:"New fee in 1e8 format"},notice:"Changes protocol performance fees"},"claimFees(address)":{inputs:[{internalType:"address",name:"_to",type:"address"}],name:"claimFees",outputs:[],stateMutability:"nonpayable",type:"function",params:{_to:"Address where the fees should be sent"},notice:"Governance claims fees received from strategy creation"},"createStrategy((address,address,uint256,uint256,uint256,address,bool[2],(int24,int24)[]))":{inputs:[{components:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"feeTo",type:"address"},{internalType:"uint256",name:"managementFeeRate",type:"uint256"},{internalType:"uint256",name:"performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"limit",type:"uint256"},{internalType:"contract IUniswapV3Pool",name:"pool",type:"address"},{internalType:"bool[2]",name:"usdAsBase",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"ticks",type:"tuple[]"}],internalType:"struct IStrategyFactory.CreateStrategyParams",name:"params",type:"tuple"}],name:"createStrategy",outputs:[],stateMutability:"payable",type:"function"},"defaultAllowedDeviation()":{inputs:[],name:"defaultAllowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"defaultAllowedSlippage()":{inputs:[],name:"defaultAllowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"defaultAllowedSwapDeviation()":{inputs:[],name:"defaultAllowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"denied(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"denied",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"deny(address,bool)":{inputs:[{internalType:"address",name:"_strategy",type:"address"},{internalType:"bool",name:"_status",type:"bool"}],name:"deny",outputs:[],stateMutability:"nonpayable",type:"function",params:{_status:"If true, it'll be blacklisted.",_strategy:"Address of the strategy"},notice:"Adds strategy to Denylist, rebalance and add liquidity will be stopped"},"deployerProxy()":{inputs:[],name:"deployerProxy",outputs:[{internalType:"contract IDefiEdgeStrategyDeployer",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"freezeEmergency()":{inputs:[],name:"freezeEmergency",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"freezeEmergencyFunctions()":{inputs:[],name:"freezeEmergencyFunctions",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Freeze emergency function, can be done only once"},"getHeartBeat(address,address)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"getHeartBeat",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_base:"base token address",_quote:"quote token address"},notice:"Fetch heartBeat for specific feeds, if hearbeat is 0 then it will return 3600 seconds by default"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isValidStrategy(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isValidStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"protocolFeeRate()":{inputs:[],name:"protocolFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"protocolPerformanceFeeRate()":{inputs:[],name:"protocolPerformanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setMinHeartbeat(address,address,uint256)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"},{internalType:"uint256",name:"_period",type:"uint256"}],name:"setMinHeartbeat",outputs:[],stateMutability:"nonpayable",type:"function",params:{_base:"base token address",_period:"heartbeat in seconds",_quote:"quote token address"},notice:"Update heartBeat for specific feeds"},"strategyByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"strategyByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyByManager(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"strategyByManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyCreationFee()":{inputs:[],name:"strategyCreationFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalIndex()":{inputs:[],name:"totalIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"uniswapV3Factory()":{inputs:[],name:"uniswapV3Factory",outputs:[{internalType:"contract IUniswapV3Factory",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/ERC20.sol:ERC20":{source:"contracts/ERC20.sol",name:"ERC20",details:"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/base/StrategyBase.sol:StrategyBase":{source:"contracts/base/StrategyBase.sol",name:"StrategyBase",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accPerformanceFeeShares()":{inputs:[],name:"accPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accProtocolPerformanceFeeShares()":{inputs:[],name:"accProtocolPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Array of the ticks"},notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract IStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"total supply of shares, including virtual supply"},notice:"Adds all the shares stored in the state variables"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"usdAsBase(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"usdAsBase",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/base/StrategyManager.sol:StrategyManager":{source:"contracts/base/StrategyManager.sol",name:"StrategyManager",constructor:{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"address"},{internalType:"address",name:"_operator",type:"address"},{internalType:"address",name:"_feeTo",type:"address"},{internalType:"uint256",name:"_managementFeeRate",type:"uint256"},{internalType:"uint256",name:"_performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"_limit",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},events:{"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"FeeChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"tier",type:"uint256"}],name:"FeeChanged",type:"event"},"FeeToChanged(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeTo",type:"address"}],name:"FeeToChanged",type:"event"},"LimitChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"limit",type:"uint256"}],name:"LimitChanged",type:"event"},"MaxSwapLimitChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"limit",type:"uint256"}],name:"MaxSwapLimitChanged",type:"event"},"OperatorChanged(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"}],name:"OperatorChanged",type:"event"},"OperatorProposed(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"}],name:"OperatorProposed",type:"event"},"PerformanceFeeChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"performanceFeeRate",type:"uint256"}],name:"PerformanceFeeChanged",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"StrategyModeUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyModeUpdated",type:"event"}},methods:{"ADMIN_ROLE()":{inputs:[],name:"ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"BURNER_ROLE()":{inputs:[],name:"BURNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MANAGER_ROLE()":{inputs:[],name:"MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MIN_DEVIATION()":{inputs:[],name:"MIN_DEVIATION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MIN_FEE()":{inputs:[],name:"MIN_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"USER_WHITELIST_ROLE()":{inputs:[],name:"USER_WHITELIST_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"only can burn the liquidity"},"acceptOperator()":{inputs:[],name:"acceptOperator",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Change the operator"},"allowedDeviation()":{inputs:[],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSwapDeviation()":{inputs:[],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeFeeTo(address)":{inputs:[{internalType:"address",name:"_newFeeTo",type:"address"}],name:"changeFeeTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newFeeTo:"New address where fees should be received"},notice:"changes address where the operator is receiving the fee"},"changeLimit(uint256)":{inputs:[{internalType:"uint256",name:"_limit",type:"uint256"}],name:"changeLimit",outputs:[],stateMutability:"nonpayable",type:"function",params:{_limit:"Number of shares the strategy can mint, 0 means unlimited"},notice:"Change strategy limit in terms of share"},"changeManagementFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeManagementFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"1e8 is 100%",params:{_fee:"Fee tier from indexes 0 to 2"},notice:"Changes the fee"},"changeMaxSwapLimit(uint256)":{inputs:[{internalType:"uint256",name:"_limit",type:"uint256"}],name:"changeMaxSwapLimit",outputs:[],stateMutability:"nonpayable",type:"function",params:{_limit:"Maximum number of swap that can be performed in a day"},notice:"Change strategy maximum swap limit for a day"},"changeOperator(address)":{inputs:[{internalType:"address",name:"_operator",type:"address"}],name:"changeOperator",outputs:[],stateMutability:"nonpayable",type:"function",params:{_operator:"Address of the new operator"},notice:"Change the operator"},"changePerformanceFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_performanceFeeRate",type:"uint256"}],name:"changePerformanceFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_performanceFeeRate:"New performance fee, should not be more than 20%"},notice:"Manager can set the performance fee"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increamentSwapCounter()":{inputs:[],name:"increamentSwapCounter",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Track total swap performed in a day and revert if maximum swap limit reached.         Can only be called by strategy contract"},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isStrategyPrivate()":{inputs:[],name:"isStrategyPrivate",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUserWhiteListed(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isUserWhiteListed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastSwapTimestamp()":{inputs:[],name:"lastSwapTimestamp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"limit()":{inputs:[],name:"limit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"managementFeeRate()":{inputs:[],name:"managementFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxAllowedSwap()":{inputs:[],name:"maxAllowedSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operator()":{inputs:[],name:"operator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingOperator()":{inputs:[],name:"pendingOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"performanceFeeRate()":{inputs:[],name:"performanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"strategy()":{inputs:[],name:"strategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"swapCounter()":{inputs:[],name:"swapCounter",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"updateStrategyMode(bool)":{inputs:[{internalType:"bool",name:"_isPrivate",type:"bool"}],name:"updateStrategyMode",outputs:[],stateMutability:"nonpayable",type:"function",params:{_isPrivate:"true - private strategy, false - public strategy"},notice:"Manager can update strategy mode -  public, private"}}},"contracts/base/UniswapV3LiquidityManager.sol:UniswapV3LiquidityManager":{source:"contracts/base/UniswapV3LiquidityManager.sol",name:"UniswapV3LiquidityManager",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accPerformanceFeeShares()":{inputs:[],name:"accPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accProtocolPerformanceFeeShares()":{inputs:[],name:"accProtocolPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},returns:{amount0:"Amount of token0's liquidity burned",amount1:"Amount of token1's liquidity burned",fee0:"Fee of token0 accumulated in the position which is being burned",fee1:"Fee of token1 accumulated in the position which is being burned"},notice:"Burn liquidity from specific tick"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAUMWithFees(bool)":{inputs:[{internalType:"bool",name:"_includeFee",type:"bool"}],name:"getAUMWithFees",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"totalFee0",type:"uint256"},{internalType:"uint256",name:"totalFee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_includeFee:"Whether to include pool fees in AUM or not. (passing true will also collect fees from pool)",amount0:"Total AUM of token0 including the fees  ( if _includeFee is passed true)",amount1:"Total AUM of token1 including the fees  ( if _includeFee is passed true)",totalFee0:"Total fee of token0 including the fees  ( if _includeFee is passed true)",totalFee1:"Total fee of token1 including the fees  ( if _includeFee is passed true)"},notice:"Get's assets under management with realtime fees"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"Array of the ticks"},notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract IStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"total supply of shares, including virtual supply"},notice:"Adds all the shares stored in the state variables"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"usdAsBase(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"usdAsBase",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IDefiEdgeStrategyDeployer.sol:IDefiEdgeStrategyDeployer":{source:"contracts/interfaces/IDefiEdgeStrategyDeployer.sol",name:"IDefiEdgeStrategyDeployer",events:{"StrategyDeployed(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyDeployed",type:"event"}},methods:{"createStrategy(address,address,address,address,address,bool[2],(int24,int24)[])":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_swapRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract IStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_usdAsBase",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],name:"createStrategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/interfaces/IERC20Minimal.sol:IERC20Minimal":{source:"contracts/interfaces/IERC20Minimal.sol",name:"IERC20Minimal",methods:{"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IOneInch.sol:IOneInch":{source:"contracts/interfaces/IOneInch.sol",name:"IOneInch"},"contracts/interfaces/IOneInchRouter.sol:IOneInchRouter":{source:"contracts/interfaces/IOneInchRouter.sol",name:"IOneInchRouter",methods:{"swap(address,address,uint256,uint256,uint256[],uint256)":{inputs:[{internalType:"contract IERC20",name:"fromToken",type:"address"},{internalType:"contract IERC20",name:"destToken",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"minReturn",type:"uint256"},{internalType:"uint256[]",name:"distribution",type:"uint256[]"},{internalType:"uint256",name:"flags",type:"uint256"}],name:"swap",outputs:[{internalType:"uint256",name:"returnAmount",type:"uint256"}],stateMutability:"nonpayable",type:"function"}}},"contracts/interfaces/IStrategyBase.sol:IStrategyBase":{source:"contracts/interfaces/IStrategyBase.sol",name:"IStrategyBase",events:{"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"}},methods:{"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accPerformanceFeeShares()":{inputs:[],name:"accPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accProtocolPerformanceFeeShares()":{inputs:[],name:"accProtocolPerformanceFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract IStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"usdAsBase(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"usdAsBase",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IStrategyFactory.sol:IStrategyFactory":{source:"contracts/interfaces/IStrategyFactory.sol",name:"IStrategyFactory",events:{"ChangeAllowedDeviation(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedDeviation",type:"event"},"ChangeAllowedSlippage(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedSlippage",type:"event"},"ChangeAllowedSwapDeviation(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"ChangeAllowedSwapDeviation",type:"event"},"ChangeDeviation(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"deviation",type:"uint256"}],name:"ChangeDeviation",type:"event"},"ChangeProtocolFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolFee",type:"event"},"ChangeProtocolPerformanceFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolPerformanceFee",type:"event"},"ChangeSlippage(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"slippage",type:"uint256"}],name:"ChangeSlippage",type:"event"},"ChangeStrategyCreationFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ChangeStrategyCreationFee",type:"event"},"ClaimFees(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ClaimFees",type:"event"},"EmergencyFrozen()":{anonymous:!1,inputs:[],name:"EmergencyFrozen",type:"event"},"NewStrategy(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!0,internalType:"address",name:"creater",type:"address"}],name:"NewStrategy",type:"event"},"StrategyStatusChanged(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyStatusChanged",type:"event"}},methods:{"allowedDeviation(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSlippage(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSwapDeviation(address)":{inputs:[{internalType:"address",name:"_pool",type:"address"}],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainlinkRegistry()":{inputs:[],name:"chainlinkRegistry",outputs:[{internalType:"contract FeedRegistryInterface",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeAllowedDeviation(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"changeAllowedDeviation",outputs:[],stateMutability:"nonpayable",type:"function"},"changeAllowedSlippage(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"changeAllowedSlippage",outputs:[],stateMutability:"nonpayable",type:"function"},"changeAllowedSwapDeviation(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"changeAllowedSwapDeviation",outputs:[],stateMutability:"nonpayable",type:"function"},"changeDefaultValues(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],name:"changeDefaultValues",outputs:[],stateMutability:"nonpayable",type:"function"},"createStrategy((address,address,uint256,uint256,uint256,address,bool[2],(int24,int24)[]))":{inputs:[{components:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"feeTo",type:"address"},{internalType:"uint256",name:"managementFeeRate",type:"uint256"},{internalType:"uint256",name:"performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"limit",type:"uint256"},{internalType:"contract IUniswapV3Pool",name:"pool",type:"address"},{internalType:"bool[2]",name:"usdAsBase",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct IStrategyBase.Tick[]",name:"ticks",type:"tuple[]"}],internalType:"struct IStrategyFactory.CreateStrategyParams",name:"params",type:"tuple"}],name:"createStrategy",outputs:[],stateMutability:"payable",type:"function"},"defaultAllowedDeviation()":{inputs:[],name:"defaultAllowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"defaultAllowedSlippage()":{inputs:[],name:"defaultAllowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"defaultAllowedSwapDeviation()":{inputs:[],name:"defaultAllowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"denied(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"denied",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"deployerProxy()":{inputs:[],name:"deployerProxy",outputs:[{internalType:"contract IDefiEdgeStrategyDeployer",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"freezeEmergency()":{inputs:[],name:"freezeEmergency",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"freezeEmergencyFunctions()":{inputs:[],name:"freezeEmergencyFunctions",outputs:[],stateMutability:"nonpayable",type:"function"},"getHeartBeat(address,address)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"getHeartBeat",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isValidStrategy(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isValidStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"protocolFeeRate()":{inputs:[],name:"protocolFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"protocolPerformanceFeeRate()":{inputs:[],name:"protocolPerformanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"strategyByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"strategyByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyByManager(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"strategyByManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyCreationFee()":{inputs:[],name:"strategyCreationFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalIndex()":{inputs:[],name:"totalIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"uniswapV3Factory()":{inputs:[],name:"uniswapV3Factory",outputs:[{internalType:"contract IUniswapV3Factory",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/interfaces/IStrategyManager.sol:IStrategyManager":{source:"contracts/interfaces/IStrategyManager.sol",name:"IStrategyManager",methods:{"allowedDeviation()":{inputs:[],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSwapDeviation()":{inputs:[],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"increamentSwapCounter()":{inputs:[],name:"increamentSwapCounter",outputs:[],stateMutability:"nonpayable",type:"function"},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUserWhiteListed(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isUserWhiteListed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"limit()":{inputs:[],name:"limit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"managementFeeRate()":{inputs:[],name:"managementFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operator()":{inputs:[],name:"operator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"performanceFeeRate()":{inputs:[],name:"performanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/libraries/CommonMath.sol:CommonMath":{source:"contracts/libraries/CommonMath.sol",name:"CommonMath"},"contracts/libraries/LiquidityHelper.sol:LiquidityHelper":{source:"contracts/libraries/LiquidityHelper.sol",name:"LiquidityHelper",methods:{"getAmountsForLiquidity(IUniswapV3Pool,int24,int24,uint128)":{inputs:[{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"},{internalType:"uint128",name:"_liquidity",type:"uint128"}],name:"getAmountsForLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"view",type:"function",params:{_liquidity:"Liquidity of the pool",_pool:"Instance of the pool",_tickLower:"Lower tick",_tickUpper:"Upper tick"},notice:"Calculates the liquidity amount using current ranges"},"getLiquidityForAmounts(IUniswapV3Pool,int24,int24,uint256,uint256)":{inputs:[{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"}],name:"getLiquidityForAmounts",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"}],stateMutability:"view",type:"function",params:{_amount0:"Amount to be added for token0",_amount1:"Amount to be added for token1",_pool:"Pool instance",_tickLower:"Lower tick",_tickUpper:"Upper tick"},returns:{liquidity:"Liquidity amount derived from token amounts"},notice:"Calculates the liquidity amount using current ranges"}}},"contracts/libraries/OneInchHelper.sol:OneInchHelper":{source:"contracts/libraries/OneInchHelper.sol",name:"OneInchHelper",methods:{"decodeData(IERC20,IERC20,bytes)":{inputs:[{internalType:"contract IERC20",name:"token0",type:"IERC20"},{internalType:"contract IERC20",name:"token1",type:"IERC20"},{internalType:"bytes",name:"data",type:"bytes"}],name:"decodeData",outputs:[{internalType:"contract IERC20",name:"srcToken",type:"IERC20"},{internalType:"contract IERC20",name:"dstToken",type:"IERC20"},{internalType:"uint256",name:"amount",type:"uint256"}],stateMutability:"view",type:"function",details:"Function decodeds srcToken, dstToken and source swap amount from the given data",params:{data:"bytes data to decode",token0:"token0 address of strategy",token1:"token1 address of strategy"}}}},"contracts/libraries/OracleLibrary.sol:OracleLibrary":{source:"contracts/libraries/OracleLibrary.sol",name:"OracleLibrary",methods:{"BASE()":{inputs:[],name:"BASE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowSwap(IUniswapV3Pool,IStrategyFactory,uint256,uint256,address,address,bool[2])":{inputs:[{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract IStrategyFactory",name:"_factory",type:"IStrategyFactory"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"bool[2]",name:"_isBase",type:"bool[2]"}],name:"allowSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_factory:"Address of the DefiEdge strategy factory",_isBase:"to take token as bas etoken or not",_pool:"Address of the pool",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped"},returns:{_0:"true if the swap is allowed, else false"},notice:"Checks for price slippage at the time of swap"},"hasDeviation(IStrategyFactory,IUniswapV3Pool,FeedRegistryInterface,bool[2],address)":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"IStrategyFactory"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract FeedRegistryInterface",name:"_registry",type:"FeedRegistryInterface"},{internalType:"bool[2]",name:"_usdAsBase",type:"bool[2]"},{internalType:"address",name:"_manager",type:"address"}],name:"hasDeviation",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_manager:"Manager contract address to check allowed deviation",_pool:"Address of the pool",_registry:"Chainlink registry interface",_usdAsBase:"checks if pegged to USD"},notice:"Checks if the the current price has deviation from the pool price"},"isSwapExceedDeviation(IStrategyFactory,IUniswapV3Pool,FeedRegistryInterface,uint256,uint256,address,address,bool[2],address)":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"IStrategyFactory"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract FeedRegistryInterface",name:"_registry",type:"FeedRegistryInterface"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"bool[2]",name:"_usdAsBase",type:"bool[2]"},{internalType:"address",name:"_manager",type:"address"}],name:"isSwapExceedDeviation",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_manager:"Manager contract address to check allowed deviation",_pool:"Address of the pool",_registry:"Chainlink registry interface",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped",_usdAsBase:"checks if pegged to USD"},notice:"Checks the if swap exceed allowed swap deviation or not"}}},"contracts/libraries/ShareHelper.sol:ShareHelper":{source:"contracts/libraries/ShareHelper.sol",name:"ShareHelper",methods:{"DIVISOR()":{inputs:[],name:"DIVISOR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateFeeShares(IStrategyFactory,IStrategyManager,uint256,uint256,uint256)":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"IStrategyFactory"},{internalType:"contract IStrategyManager",name:"_manager",type:"IStrategyManager"},{internalType:"uint256",name:"_accManagementFee",type:"uint256"},{internalType:"uint256",name:"_accPerformanceFee",type:"uint256"},{internalType:"uint256",name:"_accProtocolPerformanceFee",type:"uint256"}],name:"calculateFeeShares",outputs:[{internalType:"address",name:"managerFeeTo",type:"address"},{internalType:"address",name:"protocolFeeTo",type:"address"},{internalType:"uint256",name:"managerShare",type:"uint256"},{internalType:"uint256",name:"protocolShare",type:"uint256"}],stateMutability:"view",type:"function",params:{_accManagementFee:"Accumulated management fees in terms of shares, decimal 18",_accPerformanceFee:"Accumulated performance fee in terms of shares, decimal 18",_accProtocolPerformanceFee:"Accumulated performance fee in terms of shares, decimal 18",_factory:"Strategy factory address",_manager:"Strategy manager contract address"},notice:"Calculates the fee shares from accumulated fees"},"calculateShares(IStrategyFactory,FeedRegistryInterface,IUniswapV3Pool,bool[2],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract IStrategyFactory",name:"_factory",type:"IStrategyFactory"},{internalType:"contract FeedRegistryInterface",name:"_registry",type:"FeedRegistryInterface"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"bool[2]",name:"_isBase",type:"bool[2]"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"},{internalType:"uint256",name:"_totalShares",type:"uint256"}],name:"calculateShares",outputs:[{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculates the shares to be given for specific position",params:{_amount0:"Amount of token0",_amount1:"Amount of token1",_isBase:"Is USD used as base",_pool:"The token0",_registry:"Chainlink registry interface",_totalAmount0:"Total amount of token0",_totalAmount1:"Total amount of token1",_totalShares:"Total Number of shares"}}}},"contracts/misc/ChainlinkRegistry.sol:ChainlinkRegistry":{source:"contracts/misc/ChainlinkRegistry.sol",name:"ChainlinkRegistry",constructor:{inputs:[{internalType:"address",name:"_governance",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"acceptGovernance()":{inputs:[],name:"acceptGovernance",outputs:[],stateMutability:"nonpayable",type:"function"},"changeGovernance(address)":{inputs:[{internalType:"address",name:"_governance",type:"address"}],name:"changeGovernance",outputs:[],stateMutability:"nonpayable",type:"function"},"decimals(address,address)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"feeds(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"feeds",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"map base currencies with quote currencies"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"latestRoundData(address,address)":{inputs:[{internalType:"address",name:"base",type:"address"},{internalType:"address",name:"quote",type:"address"}],name:"latestRoundData",outputs:[{internalType:"uint80",name:"roundId",type:"uint80"},{internalType:"int256",name:"answer",type:"int256"},{internalType:"uint256",name:"startedAt",type:"uint256"},{internalType:"uint256",name:"updatedAt",type:"uint256"},{internalType:"uint80",name:"answeredInRound",type:"uint80"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"setFeed(address,address,address)":{inputs:[{internalType:"address",name:"_feed",type:"address"},{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"setFeed",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/misc/ChainlinkRegistry.sol:IAggregatorV3Interface":{source:"contracts/misc/ChainlinkRegistry.sol",name:"IAggregatorV3Interface",methods:{"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"description()":{inputs:[],name:"description",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"getRoundData(uint80)":{inputs:[{internalType:"uint80",name:"_roundId",type:"uint80"}],name:"getRoundData",outputs:[{internalType:"uint80",name:"roundId",type:"uint80"},{internalType:"int256",name:"answer",type:"int256"},{internalType:"uint256",name:"startedAt",type:"uint256"},{internalType:"uint256",name:"updatedAt",type:"uint256"},{internalType:"uint80",name:"answeredInRound",type:"uint80"}],stateMutability:"view",type:"function"},"latestRoundData()":{inputs:[],name:"latestRoundData",outputs:[{internalType:"uint80",name:"roundId",type:"uint80"},{internalType:"int256",name:"answer",type:"int256"},{internalType:"uint256",name:"startedAt",type:"uint256"},{internalType:"uint256",name:"updatedAt",type:"uint256"},{internalType:"uint80",name:"answeredInRound",type:"uint80"}],stateMutability:"view",type:"function"},"version()":{inputs:[],name:"version",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/personal/DefiEdgePrivateFactory.sol:DefiEgdePrivateFactory":{source:"contracts/personal/DefiEdgePrivateFactory.sol",name:"DefiEgdePrivateFactory",constructor:{inputs:[{internalType:"address",name:"_governance",type:"address"},{internalType:"address",name:"_oneInchRouter",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"ChangeProtocolFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolFee",type:"event"},"NewStrategy(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"address",name:"operator",type:"address"}],name:"NewStrategy",type:"event"}},methods:{"MAX_PROTOCOL_PERFORMANCE_FEES_RATE()":{inputs:[],name:"MAX_PROTOCOL_PERFORMANCE_FEES_RATE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PROTOCOL_FEE()":{inputs:[],name:"PROTOCOL_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acceptGovernance()":{inputs:[],name:"acceptGovernance",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Change the operator"},"changeGovernance(address)":{inputs:[{internalType:"address",name:"_governance",type:"address"}],name:"changeGovernance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_governance:"Address of the new governance"},notice:"Change the governance address"},"changeProtocolFee(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeProtocolFee",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fee:"New fee, should be less than 20%"},notice:"Change protocol fee"},"createStrategy(address,address)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"address",name:"_operator",type:"address"}],name:"createStrategy",outputs:[],stateMutability:"nonpayable",type:"function",params:{_operator:"Address of the operator",_pool:"Address of the pool"},notice:"Create private strategy"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"strategyByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"totalIndex()":{inputs:[],name:"totalIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/personal/DefiEdgePrivateManager.sol:DefiEdgePrivateManager":{source:"contracts/personal/DefiEdgePrivateManager.sol",name:"DefiEdgePrivateManager",constructor:{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"address",name:"_operator",type:"address"},{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_oneInchRouter",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Deposit(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Deposit",type:"event"},"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"Hold()":{anonymous:!1,inputs:[],name:"Hold",type:"event"},"PartialRebalance((uint256,bool,uint256,uint256)[])":{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],indexed:!1,internalType:"struct DefiEdgePrivateManager.PartialTick[]",name:"ticks",type:"tuple[]"}],name:"PartialRebalance",type:"event"},"Rebalance((uint256,uint256,int24,int24)[])":{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],indexed:!1,internalType:"struct UniswapV3PersonalLiquidityManager.Tick[]",name:"ticks",type:"tuple[]"}],name:"Rebalance",type:"event"},"Rescue(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Rescue",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"},"Withdraw(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Withdraw",type:"event"}},methods:{"ADMIN_ROLE()":{inputs:[],name:"ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"BURNER_ROLE()":{inputs:[],name:"BURNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MANAGER_ROLE()":{inputs:[],name:"MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},notice:"Burn liquidity from specific tick"},"deposit(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"}],name:"deposit",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount0:"Amount of token0 to be deposited",_amount1:"Amount of token1 to be deposited"},notice:"Deposit funds to the Manager contract"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"rebalance(bytes,(uint256,bool,uint256,uint256)[],(uint256,uint256,int24,int24)[],bool)":{inputs:[{internalType:"bytes",name:"_swapData",type:"bytes"},{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgePrivateManager.PartialTick[]",name:"_existingTicks",type:"tuple[]"},{components:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct UniswapV3PersonalLiquidityManager.Tick[]",name:"_newTicks",type:"tuple[]"},{internalType:"bool",name:"_burnAll",type:"bool"}],name:"rebalance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_burnAll:"When burning into new ticks, should we burn all liquidity?",_existingTicks:"Array of existing ticks to rebalance",_newTicks:"New ticks in case there are any",_swapData:"Swap data to perform exchange from 1inch"},notice:"Rebalances the strategy"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"rescue(address,address,uint256)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"rescue",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount:"Number of tokens to rescue",_to:"Address where the tokens should be sent",_token:"Address of the token"},notice:"Rescue any tokens"},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"withdraw(uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{_amount0:"Amount of token0 to be withdrawn",_amount1:"Amount of token1 to be withdrawn"},notice:"Withdraw funds"}}},"contracts/personal/UniswapV3PrivateLiquidityManager.sol:IFactory":{source:"contracts/personal/UniswapV3PrivateLiquidityManager.sol",name:"IFactory",methods:{"PROTOCOL_FEE()":{inputs:[],name:"PROTOCOL_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/personal/UniswapV3PrivateLiquidityManager.sol:PrivateManagerBase":{source:"contracts/personal/UniswapV3PrivateLiquidityManager.sol",name:"PrivateManagerBase",events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"ADMIN_ROLE()":{inputs:[],name:"ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"BURNER_ROLE()":{inputs:[],name:"BURNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MANAGER_ROLE()":{inputs:[],name:"MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}}},"contracts/personal/UniswapV3PrivateLiquidityManager.sol:UniswapV3PersonalLiquidityManager":{source:"contracts/personal/UniswapV3PrivateLiquidityManager.sol",name:"UniswapV3PersonalLiquidityManager",events:{"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"}},methods:{"ADMIN_ROLE()":{inputs:[],name:"ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"BURNER_ROLE()":{inputs:[],name:"BURNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MANAGER_ROLE()":{inputs:[],name:"MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},notice:"Burn liquidity from specific tick"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract IFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."}}},"contracts/test/ERC20.sol:TestToken":{source:"contracts/test/ERC20.sol",name:"TestToken",details:"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",constructor:{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"},{internalType:"uint8",name:"decimals_",type:"uint8"},{internalType:"uint256",name:"mintAmt_",type:"uint256"},{internalType:"address",name:"mintTo_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"Creates `amount` tokens and assigns them to `account`, increasing the total supply. w Emits a {Transfer} event with `from` set to the zero address. Requirements: - `to` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/test/TestERC20.sol:TestERC20":{source:"contracts/test/TestERC20.sol",name:"TestERC20",details:"Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",constructor:{inputs:[{internalType:"uint8",name:"decimals_",type:"uint8"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function",details:"Creates `amount` tokens and assigns them to `account`, increasing the total supply. w Emits a {Transfer} event with `from` set to the zero address. Requirements: - `to` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/test/TestSwap.sol:Periphery":{source:"contracts/test/TestSwap.sol",name:"Periphery",methods:{"mintLiquidity(address,int24,int24,uint256,uint256,address)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"address",name:"_payer",type:"address"}],name:"mintLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_amount0:"Amount of token0",_amount1:"Amount of token1",_payer:"Address which is adding the liquidity",_pool:"Address of the pool",_tickLower:"Lower tick",_tickUpper:"Upper tick"},notice:"Mints liquidity from V3 Pool"},"swap(address,bool,int256,uint160)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"bool",name:"_zeroToOne",type:"bool"},{internalType:"int256",name:"_amount",type:"int256"},{internalType:"uint160",name:"_sqrtPriceLimitX96",type:"uint160"}],name:"swap",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."}}},"contracts/test/UniswapV3OracleTest.sol:UniswapV3OracleTest":{source:"contracts/test/UniswapV3OracleTest.sol",name:"UniswapV3OracleTest",methods:{"consult(address,uint32)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint32",name:"_period",type:"uint32"}],name:"consult",outputs:[{internalType:"uint256",name:"price",type:"uint256"}],stateMutability:"view",type:"function",params:{_period:"Seconds from which the data needs to be queried",_pool:"Address of the pool"},returns:{price:"Price of the assets calculated from Uniswap V3 Oracle"},notice:"Consults V3 TWAP oracle"}}},"contracts/test/WETH9.sol:WETH9":{source:"contracts/test/WETH9.sol",name:"WETH9",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"src",type:"address"},{indexed:!0,internalType:"address",name:"guy",type:"address"},{indexed:!1,internalType:"uint256",name:"wad",type:"uint256"}],name:"Approval",type:"event"},"Deposit(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"dst",type:"address"},{indexed:!1,internalType:"uint256",name:"wad",type:"uint256"}],name:"Deposit",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"src",type:"address"},{indexed:!0,internalType:"address",name:"dst",type:"address"},{indexed:!1,internalType:"uint256",name:"wad",type:"uint256"}],name:"Transfer",type:"event"},"Withdrawal(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"src",type:"address"},{indexed:!1,internalType:"uint256",name:"wad",type:"uint256"}],name:"Withdrawal",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"guy",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"src",type:"address"},{internalType:"address",name:"dst",type:"address"},{internalType:"uint256",name:"wad",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/test/chainlink/RegistryMock.sol:ChainlinkRegistryMock":{source:"contracts/test/chainlink/RegistryMock.sol",name:"ChainlinkRegistryMock",constructor:{inputs:[{internalType:"address",name:"_token0",type:"address"},{internalType:"address",name:"_token1",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"decimals(address,address)":{inputs:[{internalType:"address",name:"base",type:"address"},{internalType:"address",name:"quote",type:"address"}],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"latestRoundData(address,address)":{inputs:[{internalType:"address",name:"base",type:"address"},{internalType:"address",name:"quote",type:"address"}],name:"latestRoundData",outputs:[{internalType:"uint80",name:"roundId",type:"uint80"},{internalType:"int256",name:"answer",type:"int256"},{internalType:"uint256",name:"startedAt",type:"uint256"},{internalType:"uint256",name:"updatedAt",type:"uint256"},{internalType:"uint80",name:"answeredInRound",type:"uint80"}],stateMutability:"view",type:"function"},"setAnswer(int256,int256)":{inputs:[{internalType:"int256",name:"_token0Answer",type:"int256"},{internalType:"int256",name:"_token1Answer",type:"int256"}],name:"setAnswer",outputs:[],stateMutability:"nonpayable",type:"function"},"setDecimals(uint8)":{inputs:[{internalType:"uint8",name:"_newDecimals",type:"uint8"}],name:"setDecimals",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/test/core/NoDelegateCall.sol:NoDelegateCall":{source:"contracts/test/core/NoDelegateCall.sol",name:"NoDelegateCall",title:"Prevents delegatecall to a contract",notice:"Base contract that provides a modifier for preventing delegatecall to methods in a child contract"},"contracts/test/core/UniswapV3Factory.sol:UniswapV3Factory":{source:"contracts/test/core/UniswapV3Factory.sol",name:"UniswapV3Factory",title:"Canonical Uniswap V3 factory",notice:"Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"FeeAmountEnabled(uint24,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!0,internalType:"int24",name:"tickSpacing",type:"int24"}],name:"FeeAmountEnabled",type:"event",notice:"Emitted when a new fee amount is enabled for pool creation via the factory"},"OwnerChanged(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnerChanged",type:"event",notice:"Emitted when the owner of the factory is changed"},"PoolCreated(address,address,uint24,int24,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!1,internalType:"int24",name:"tickSpacing",type:"int24"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event",notice:"Emitted when a pool is created"}},stateVariables:{"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"Can be changed by the current owner via setOwner",return:"The address of the factory owner",notice:"Returns the current owner of the factory"}},methods:{"createPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"createPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"nonpayable",type:"function",details:"tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.",params:{fee:"The desired fee for the pool",tokenA:"One of the two tokens in the desired pool",tokenB:"The other of the two tokens in the desired pool"},returns:{pool:"The address of the newly created pool"},notice:"Creates a pool for the given two tokens and fee"},"enableFeeAmount(uint24,int24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],name:"enableFeeAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Fee amounts may never be removed once enabled",params:{fee:"The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)",tickSpacing:"The spacing between ticks to be enforced for all pools created with the given fee amount"},notice:"Enables a fee amount with the given tickSpacing"},"feeAmountTickSpacing(uint24)":{inputs:[{internalType:"uint24",name:"",type:"uint24"}],name:"feeAmountTickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",notice:"Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled"},"getPool(address,address,uint24)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint24",name:"",type:"uint24"}],name:"getPool",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist"},"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"function",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."},"setOwner(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"setOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"Must be called by the current owner",params:{_owner:"The new owner of the factory"},notice:"Updates the owner of the factory"}}},"contracts/test/core/UniswapV3Pool.sol:UniswapV3Pool":{source:"contracts/test/core/UniswapV3Pool.sol",name:"UniswapV3Pool",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",notice:"Emitted by the pool for any swaps between token0 and token1"}},stateVariables:{"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The contract address",notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"stateVariable",return:"The fee",notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",return:"The max amount of liquidity per tick",notice:"The maximum amount of position liquidity that can use any tick in the range"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"stateVariable",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"stateVariable",return:"sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy",notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"stateVariable",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",return:"The tick spacing",notice:"The pool tick spacing"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The token contract address",notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"The token contract address",notice:"The second of the two tokens of the pool, sorted by address"}},methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"noDelegateCall is applied indirectly via _modifyPosition",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"getAmountsForTick(address,int24,int24)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"}],name:"getAmountsForTick",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"view",type:"function"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"not locked because it initializes unlocked",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"noDelegateCall is applied indirectly via _modifyPosition",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",notice:"Returns data about a specific observation index"},"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",notice:"Returns the information about a position by the position's key"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"ticks(int24)":{inputs:[{internalType:"int24",name:"",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",notice:"Look up information about a specific tick in the pool"}}},"contracts/test/core/UniswapV3PoolDeployer.sol:UniswapV3PoolDeployer":{source:"contracts/test/core/UniswapV3PoolDeployer.sol",name:"UniswapV3PoolDeployer",stateVariables:{"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"stateVariable",details:"Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."}}},"contracts/test/core/interfaces/IERC20Minimal.sol:IERC20Minimal":{source:"contracts/test/core/interfaces/IERC20Minimal.sol",name:"IERC20Minimal",title:"Minimal ERC20 interface for Uniswap",notice:"Contains a subset of the full ERC20 interface that is used in Uniswap V3",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",params:{owner:"The account that approved spending of its tokens",spender:"The account for which the spending allowance was modified",value:"The new allowance from the owner to the spender"},notice:"Event emitted when the approval amount for the spender of a given owner's tokens changes."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",params:{from:"The account from which the tokens were sent, i.e. the balance decreased",to:"The account to which the tokens were sent, i.e. the balance increased",value:"The amount of tokens that were transferred"},notice:"Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{owner:"The account of the token owner",spender:"The account of the token spender"},returns:{_0:"The current allowance granted by `owner` to `spender`"},notice:"Returns the current allowance given to a spender by an owner"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The amount of tokens allowed to be used by `spender`",spender:"The account which will be allowed to spend a given amount of the owners tokens"},returns:{_0:"Returns true for a successful approval, false for unsuccessful"},notice:"Sets the allowance of a spender from the `msg.sender` to the value `amount`"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"The account for which to look up the number of tokens it has, i.e. its balance"},returns:{_0:"The number of tokens held by the account"},notice:"Returns the balance of a token"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The number of tokens to send from the sender to the recipient",recipient:"The account that will receive the amount transferred"},returns:{_0:"Returns true for a successful transfer, false for an unsuccessful transfer"},notice:"Transfers the amount of token from the `msg.sender` to the recipient"},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",params:{amount:"The amount of the transfer",recipient:"The recipient of the transfer",sender:"The account from which the transfer will be initiated"},returns:{_0:"Returns true for a successful transfer, false for unsuccessful"},notice:"Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`"}}},"contracts/test/core/interfaces/IUniswapV3Factory.sol:IUniswapV3Factory":{source:"contracts/test/core/interfaces/IUniswapV3Factory.sol",name:"IUniswapV3Factory",title:"The interface for the Uniswap V3 Factory",notice:"The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees",events:{"FeeAmountEnabled(uint24,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!0,internalType:"int24",name:"tickSpacing",type:"int24"}],name:"FeeAmountEnabled",type:"event",params:{fee:"The enabled fee, denominated in hundredths of a bip",tickSpacing:"The minimum number of ticks between initialized ticks for pools created with the given fee"},notice:"Emitted when a new fee amount is enabled for pool creation via the factory"},"OwnerChanged(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnerChanged",type:"event",params:{newOwner:"The owner after the owner was changed",oldOwner:"The owner before the owner was changed"},notice:"Emitted when the owner of the factory is changed"},"PoolCreated(address,address,uint24,int24,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token0",type:"address"},{indexed:!0,internalType:"address",name:"token1",type:"address"},{indexed:!0,internalType:"uint24",name:"fee",type:"uint24"},{indexed:!1,internalType:"int24",name:"tickSpacing",type:"int24"},{indexed:!1,internalType:"address",name:"pool",type:"address"}],name:"PoolCreated",type:"event",params:{fee:"The fee collected upon every swap in the pool, denominated in hundredths of a bip",pool:"The address of the created pool",tickSpacing:"The minimum number of ticks between initialized ticks",token0:"The first token of the pool by address sort order",token1:"The second token of the pool by address sort order"},notice:"Emitted when a pool is created"}},methods:{"createPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"createPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"nonpayable",type:"function",details:"tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments are invalid.",params:{fee:"The desired fee for the pool",tokenA:"One of the two tokens in the desired pool",tokenB:"The other of the two tokens in the desired pool"},returns:{pool:"The address of the newly created pool"},notice:"Creates a pool for the given two tokens and fee"},"enableFeeAmount(uint24,int24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],name:"enableFeeAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Fee amounts may never be removed once enabled",params:{fee:"The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)",tickSpacing:"The spacing between ticks to be enforced for all pools created with the given fee amount"},notice:"Enables a fee amount with the given tickSpacing"},"feeAmountTickSpacing(uint24)":{inputs:[{internalType:"uint24",name:"fee",type:"uint24"}],name:"feeAmountTickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"A fee amount can never be removed, so this value should be hard coded or cached in the calling context",params:{fee:"The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee"},returns:{_0:"The tick spacing"},notice:"Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled"},"getPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"getPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"view",type:"function",details:"tokenA and tokenB may be passed in either token0/token1 or token1/token0 order",params:{fee:"The fee collected upon every swap in the pool, denominated in hundredths of a bip",tokenA:"The contract address of either token0 or token1",tokenB:"The contract address of the other token"},returns:{pool:"The pool address"},notice:"Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Can be changed by the current owner via setOwner",returns:{_0:"The address of the factory owner"},notice:"Returns the current owner of the factory"},"setOwner(address)":{inputs:[{internalType:"address",name:"_owner",type:"address"}],name:"setOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"Must be called by the current owner",params:{_owner:"The new owner of the factory"},notice:"Updates the owner of the factory"}}},"contracts/test/core/interfaces/IUniswapV3Pool.sol:IUniswapV3Pool":{source:"contracts/test/core/interfaces/IUniswapV3Pool.sol",name:"IUniswapV3Pool",title:"The interface for a Uniswap V3 Pool",details:"The pool interface is broken up into many smaller pieces",notice:"A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform to the ERC20 specification",events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",notice:"Emitted by the pool for any swaps between token0 and token1"}},methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0Fees must be collected separately via a call to #collect",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The contract address"},notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"function",returns:{_0:"The fee"},notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",returns:{_0:"The max amount of liquidity per tick"},notice:"The maximum amount of position liquidity that can use any tick in the range"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",details:"You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.",params:{index:"The element of the observations array to fetch"},returns:{blockTimestamp:"The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use"},notice:"Returns data about a specific observation index"},"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"key",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"_liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",params:{key:"The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper"},returns:{_liquidity:"The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke"},notice:"Returns the information about a position by the position's key"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"function",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"function",returns:{sqrtPriceX96:"The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy"},notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"wordPosition",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",returns:{_0:"The tick spacing"},notice:"The pool tick spacing"},"ticks(int24)":{inputs:[{internalType:"int24",name:"tick",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",params:{tick:"The tick to look up"},returns:{liquidityGross:"the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position."},notice:"Look up information about a specific tick in the pool"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The second of the two tokens of the pool, sorted by address"}}},"contracts/test/core/interfaces/IUniswapV3PoolDeployer.sol:IUniswapV3PoolDeployer":{source:"contracts/test/core/interfaces/IUniswapV3PoolDeployer.sol",name:"IUniswapV3PoolDeployer",title:"An interface for a contract that is capable of deploying Uniswap V3 Pools",details:"This is used to avoid having constructor arguments in the pool contract, which results in the init code hash of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain",notice:"A contract that constructs a pool must implement this to pass arguments to the pool",methods:{"parameters()":{inputs:[],name:"parameters",outputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickSpacing",type:"int24"}],stateMutability:"view",type:"function",details:"Called by the pool constructor to fetch the parameters of the pool Returns factory The factory address Returns token0 The first token of the pool by address sort order Returns token1 The second token of the pool by address sort order Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip Returns tickSpacing The minimum number of ticks between initialized ticks",notice:"Get the parameters to be used in constructing the pool, set transiently during pool creation."}}},"contracts/test/core/interfaces/callback/IUniswapV3FlashCallback.sol:IUniswapV3FlashCallback":{source:"contracts/test/core/interfaces/callback/IUniswapV3FlashCallback.sol",name:"IUniswapV3FlashCallback",title:"Callback for IUniswapV3PoolActions#flash",notice:"Any contract that calls IUniswapV3PoolActions#flash must implement this interface",methods:{"uniswapV3FlashCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3FlashCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{data:"Any data passed through by the caller via the IUniswapV3PoolActions#flash call",fee0:"The fee amount in token0 due to the pool by the end of the flash",fee1:"The fee amount in token1 due to the pool by the end of the flash"},notice:"Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash."}}},"contracts/test/core/interfaces/callback/IUniswapV3MintCallback.sol:IUniswapV3MintCallback":{source:"contracts/test/core/interfaces/callback/IUniswapV3MintCallback.sol",name:"IUniswapV3MintCallback",title:"Callback for IUniswapV3PoolActions#mint",notice:"Any contract that calls IUniswapV3PoolActions#mint must implement this interface",methods:{"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."}}},"contracts/test/core/interfaces/callback/IUniswapV3SwapCallback.sol:IUniswapV3SwapCallback":{source:"contracts/test/core/interfaces/callback/IUniswapV3SwapCallback.sol",name:"IUniswapV3SwapCallback",title:"Callback for IUniswapV3PoolActions#swap",notice:"Any contract that calls IUniswapV3PoolActions#swap must implement this interface",methods:{"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolActions.sol:IUniswapV3PoolActions":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolActions.sol",name:"IUniswapV3PoolActions",title:"Permissionless pool actions",notice:"Contains pool methods that can be called by anyone",methods:{"burn(int24,int24,uint128)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"}],name:"burn",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0Fees must be collected separately via a call to #collect",params:{amount:"How much liquidity to burn",tickLower:"The lower tick of the position for which to burn liquidity",tickUpper:"The upper tick of the position for which to burn liquidity"},returns:{amount0:"The amount of token0 sent to the recipient",amount1:"The amount of token1 sent to the recipient"},notice:"Burn liquidity from the sender and account tokens owed for the liquidity to the position"},"collect(address,int24,int24,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collect",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",details:"Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity. Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.",params:{amount0Requested:"How much token0 should be withdrawn from the fees owed",amount1Requested:"How much token1 should be withdrawn from the fees owed",recipient:"The address which should receive the fees collected",tickLower:"The lower tick of the position for which to collect fees",tickUpper:"The upper tick of the position for which to collect fees"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects tokens owed to a position"},"flash(address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"flash",outputs:[],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallbackCan be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling with 0 amount{0,1} and sending the donation amount(s) from the callback",params:{amount0:"The amount of token0 to send",amount1:"The amount of token1 to send",data:"Any data to be passed through to the callback",recipient:"The address which will receive the token0 and token1 amounts"},notice:"Receive token0 and/or token1 and pay it back, plus a fee, in the callback"},"increaseObservationCardinalityNext(uint16)":{inputs:[{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"}],name:"increaseObservationCardinalityNext",outputs:[],stateMutability:"nonpayable",type:"function",details:"This method is no-op if the pool already has an observationCardinalityNext greater than or equal to the input observationCardinalityNext.",params:{observationCardinalityNext:"The desired minimum number of observations for the pool to store"},notice:"Increase the maximum number of price and liquidity observations that this pool will store"},"initialize(uint160)":{inputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value",params:{sqrtPriceX96:"the initial sqrt price of the pool as a Q64.96"},notice:"Sets the initial price for the pool"},"mint(address,int24,int24,uint128,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"amount",type:"uint128"},{internalType:"bytes",name:"data",type:"bytes"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends on tickLower, tickUpper, the amount of liquidity, and the current price.",params:{amount:"The amount of liquidity to mint",data:"Any data that should be passed through to the callback",recipient:"The address for which the liquidity will be created",tickLower:"The lower tick of the position in which to add liquidity",tickUpper:"The upper tick of the position in which to add liquidity"},returns:{amount0:"The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback",amount1:"The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback"},notice:"Adds liquidity for the given recipient/tickLower/tickUpper position"},"swap(address,bool,int256,uint160,bytes)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"bool",name:"zeroForOne",type:"bool"},{internalType:"int256",name:"amountSpecified",type:"int256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"},{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[{internalType:"int256",name:"amount0",type:"int256"},{internalType:"int256",name:"amount1",type:"int256"}],stateMutability:"nonpayable",type:"function",details:"The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback",params:{amountSpecified:"The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)",data:"Any data to be passed through to the callback",recipient:"The address to receive the output of the swap",sqrtPriceLimitX96:"The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap",zeroForOne:"The direction of the swap, true for token0 to token1, false for token1 to token0"},returns:{amount0:"The delta of the balance of token0 of the pool, exact when negative, minimum when positive",amount1:"The delta of the balance of token1 of the pool, exact when negative, minimum when positive"},notice:"Swap token0 for token1, or token1 for token0"}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolDerivedState.sol:IUniswapV3PoolDerivedState":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolDerivedState.sol",name:"IUniswapV3PoolDerivedState",title:"Pool state that is not stored",notice:"Contains view functions to provide information about the pool that is computed rather than stored on the blockchain. The functions here may have variable gas costs.",methods:{"observe(uint32[])":{inputs:[{internalType:"uint32[]",name:"secondsAgos",type:"uint32[]"}],name:"observe",outputs:[{internalType:"int56[]",name:"tickCumulatives",type:"int56[]"},{internalType:"uint160[]",name:"secondsPerLiquidityCumulativeX128s",type:"uint160[]"}],stateMutability:"view",type:"function",details:"To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick, you must call it with secondsAgos = [3600, 0].The time weighted average tick represents the geometric time weighted average price of the pool, in log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.",params:{secondsAgos:"From how long ago each cumulative tick and liquidity value should be returned"},returns:{secondsPerLiquidityCumulativeX128s:"Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block timestamp",tickCumulatives:"Cumulative tick values as of each `secondsAgos` from the current block timestamp"},notice:"Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp"},"snapshotCumulativesInside(int24,int24)":{inputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],name:"snapshotCumulativesInside",outputs:[{internalType:"int56",name:"tickCumulativeInside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityInsideX128",type:"uint160"},{internalType:"uint32",name:"secondsInside",type:"uint32"}],stateMutability:"view",type:"function",details:"Snapshots must only be compared to other snapshots, taken over a period for which a position existed. I.e., snapshots cannot be compared if a position is not held for the entire period between when the first snapshot is taken and the second snapshot is taken.",params:{tickLower:"The lower tick of the range",tickUpper:"The upper tick of the range"},returns:{secondsInside:"The snapshot of seconds per liquidity for the range",secondsPerLiquidityInsideX128:"The snapshot of seconds per liquidity for the range",tickCumulativeInside:"The snapshot of the tick accumulator for the range"},notice:"Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range"}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolEvents.sol:IUniswapV3PoolEvents":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolEvents.sol",name:"IUniswapV3PoolEvents",title:"Events emitted by a pool",notice:"Contains all events emitted by the pool",events:{"Burn(address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event",details:"Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect",params:{amount:"The amount of liquidity to remove",amount0:"The amount of token0 withdrawn",amount1:"The amount of token1 withdrawn",owner:"The owner of the position for which liquidity is removed",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when a position's liquidity is removed"},"Collect(address,address,int24,int24,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"Collect",type:"event",details:"Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees",params:{amount0:"The amount of token0 fees collected",amount1:"The amount of token1 fees collected",owner:"The owner of the position for which fees are collected",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when fees are collected by the owner of a position"},"CollectProtocol(address,address,uint128,uint128)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint128",name:"amount0",type:"uint128"},{indexed:!1,internalType:"uint128",name:"amount1",type:"uint128"}],name:"CollectProtocol",type:"event",params:{amount0:"The amount of token1 protocol fees that is withdrawn",recipient:"The address that receives the collected protocol fees",sender:"The address that collects the protocol fees"},notice:"Emitted when the collected protocol fees are withdrawn by the factory owner"},"Flash(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"paid1",type:"uint256"}],name:"Flash",type:"event",params:{amount0:"The amount of token0 that was flashed",amount1:"The amount of token1 that was flashed",paid0:"The amount of token0 paid for the flash, which can exceed the amount0 plus the fee",paid1:"The amount of token1 paid for the flash, which can exceed the amount1 plus the fee",recipient:"The address that received the tokens from flash",sender:"The address that initiated the swap call, and that received the callback"},notice:"Emitted by the pool for any flashes of token0/token1"},"IncreaseObservationCardinalityNext(uint16,uint16)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint16",name:"observationCardinalityNextOld",type:"uint16"},{indexed:!1,internalType:"uint16",name:"observationCardinalityNextNew",type:"uint16"}],name:"IncreaseObservationCardinalityNext",type:"event",details:"observationCardinalityNext is not the observation cardinality until an observation is written at the index just before a mint/swap/burn.",params:{observationCardinalityNextNew:"The updated value of the next observation cardinality",observationCardinalityNextOld:"The previous value of the next observation cardinality"},notice:"Emitted by the pool for increases to the number of observations that can be stored"},"Initialize(uint160,int24)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Initialize",type:"event",details:"Mint/Burn/Swap cannot be emitted by the pool before Initialize",params:{sqrtPriceX96:"The initial sqrt price of the pool, as a Q64.96",tick:"The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool"},notice:"Emitted exactly once by a pool when #initialize is first called on the pool"},"Mint(address,address,int24,int24,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"int24",name:"tickLower",type:"int24"},{indexed:!0,internalType:"int24",name:"tickUpper",type:"int24"},{indexed:!1,internalType:"uint128",name:"amount",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event",params:{amount:"The amount of liquidity minted to the position range",amount0:"How much token0 was required for the minted liquidity",amount1:"How much token1 was required for the minted liquidity",owner:"The owner of the position and recipient of any minted liquidity",sender:"The address that minted the liquidity",tickLower:"The lower tick of the position",tickUpper:"The upper tick of the position"},notice:"Emitted when liquidity is minted for a given position"},"SetFeeProtocol(uint8,uint8,uint8,uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"feeProtocol0Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1Old",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol0New",type:"uint8"},{indexed:!1,internalType:"uint8",name:"feeProtocol1New",type:"uint8"}],name:"SetFeeProtocol",type:"event",params:{feeProtocol0New:"The updated value of the token0 protocol fee",feeProtocol0Old:"The previous value of the token0 protocol fee",feeProtocol1New:"The updated value of the token1 protocol fee",feeProtocol1Old:"The previous value of the token1 protocol fee"},notice:"Emitted when the protocol fee is changed by the pool"},"Swap(address,address,int256,int256,uint160,int24)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"sender",type:"address"},{indexed:!0,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"int256",name:"amount0",type:"int256"},{indexed:!1,internalType:"int256",name:"amount1",type:"int256"},{indexed:!1,internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{indexed:!1,internalType:"int24",name:"tick",type:"int24"}],name:"Swap",type:"event",params:{amount0:"The delta of the token0 balance of the pool",amount1:"The delta of the token1 balance of the pool",recipient:"The address that received the output of the swap",sender:"The address that initiated the swap call, and that received the callback",sqrtPriceX96:"The sqrt(price) of the pool after the swap, as a Q64.96",tick:"The log base 1.0001 of price of the pool after the swap"},notice:"Emitted by the pool for any swaps between token0 and token1"}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolImmutables.sol:IUniswapV3PoolImmutables":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolImmutables.sol",name:"IUniswapV3PoolImmutables",title:"Pool state that never changes",notice:"These parameters are fixed for a pool forever, i.e., the methods will always return the same values",methods:{"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The contract address"},notice:"The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface"},"fee()":{inputs:[],name:"fee",outputs:[{internalType:"uint24",name:"",type:"uint24"}],stateMutability:"view",type:"function",returns:{_0:"The fee"},notice:"The pool's fee in hundredths of a bip, i.e. 1e-6"},"maxLiquidityPerTick()":{inputs:[],name:"maxLiquidityPerTick",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool",returns:{_0:"The max amount of liquidity per tick"},notice:"The maximum amount of position liquidity that can use any tick in the range"},"tickSpacing()":{inputs:[],name:"tickSpacing",outputs:[{internalType:"int24",name:"",type:"int24"}],stateMutability:"view",type:"function",details:"Ticks can only be used at multiples of this value, minimum of 1 and always positive e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ... This value is an int24 to avoid casting even though it is always positive.",returns:{_0:"The tick spacing"},notice:"The pool tick spacing"},"token0()":{inputs:[],name:"token0",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The first of the two tokens of the pool, sorted by address"},"token1()":{inputs:[],name:"token1",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"The token contract address"},notice:"The second of the two tokens of the pool, sorted by address"}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolOwnerActions.sol:IUniswapV3PoolOwnerActions":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolOwnerActions.sol",name:"IUniswapV3PoolOwnerActions",title:"Permissioned pool actions",notice:"Contains pool methods that may only be called by the factory owner",methods:{"collectProtocol(address,uint128,uint128)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Requested",type:"uint128"},{internalType:"uint128",name:"amount1Requested",type:"uint128"}],name:"collectProtocol",outputs:[{internalType:"uint128",name:"amount0",type:"uint128"},{internalType:"uint128",name:"amount1",type:"uint128"}],stateMutability:"nonpayable",type:"function",params:{amount0Requested:"The maximum amount of token0 to send, can be 0 to collect fees in only token1",amount1Requested:"The maximum amount of token1 to send, can be 0 to collect fees in only token0",recipient:"The address to which collected protocol fees should be sent"},returns:{amount0:"The protocol fee collected in token0",amount1:"The protocol fee collected in token1"},notice:"Collect the protocol fee accrued to the pool"},"setFeeProtocol(uint8,uint8)":{inputs:[{internalType:"uint8",name:"feeProtocol0",type:"uint8"},{internalType:"uint8",name:"feeProtocol1",type:"uint8"}],name:"setFeeProtocol",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeProtocol0:"new protocol fee for token0 of the pool",feeProtocol1:"new protocol fee for token1 of the pool"},notice:"Set the denominator of the protocol's % share of the fees"}}},"contracts/test/core/interfaces/pool/IUniswapV3PoolState.sol:IUniswapV3PoolState":{source:"contracts/test/core/interfaces/pool/IUniswapV3PoolState.sol",name:"IUniswapV3PoolState",title:"Pool state that can change",notice:"These methods compose the pool's state, and can change with any frequency including multiple times per transaction",methods:{"feeGrowthGlobal0X128()":{inputs:[],name:"feeGrowthGlobal0X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool"},"feeGrowthGlobal1X128()":{inputs:[],name:"feeGrowthGlobal1X128",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"This value can overflow the uint256",notice:"The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool"},"liquidity()":{inputs:[],name:"liquidity",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"This value has no relationship to the total liquidity across all ticks",notice:"The currently in range liquidity available to the pool"},"observations(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"observations",outputs:[{internalType:"uint32",name:"blockTimestamp",type:"uint32"},{internalType:"int56",name:"tickCumulative",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityCumulativeX128",type:"uint160"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",details:"You most likely want to use #observe() instead of this method to get an observation as of some amount of time ago, rather than at a specific index in the array.",params:{index:"The element of the observations array to fetch"},returns:{blockTimestamp:"The timestamp of the observation, Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp, Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp, Returns initialized whether the observation has been initialized and the values are safe to use"},notice:"Returns data about a specific observation index"},"positions(bytes32)":{inputs:[{internalType:"bytes32",name:"key",type:"bytes32"}],name:"positions",outputs:[{internalType:"uint128",name:"_liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",params:{key:"The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper"},returns:{_liquidity:"The amount of liquidity in the position, Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke, Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke, Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke, Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke"},notice:"Returns the information about a position by the position's key"},"protocolFees()":{inputs:[],name:"protocolFees",outputs:[{internalType:"uint128",name:"token0",type:"uint128"},{internalType:"uint128",name:"token1",type:"uint128"}],stateMutability:"view",type:"function",details:"Protocol fees will never exceed uint128 max in either token",notice:"The amounts of token0 and token1 that are owed to the protocol"},"slot0()":{inputs:[],name:"slot0",outputs:[{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"},{internalType:"int24",name:"tick",type:"int24"},{internalType:"uint16",name:"observationIndex",type:"uint16"},{internalType:"uint16",name:"observationCardinality",type:"uint16"},{internalType:"uint16",name:"observationCardinalityNext",type:"uint16"},{internalType:"uint8",name:"feeProtocol",type:"uint8"},{internalType:"bool",name:"unlocked",type:"bool"}],stateMutability:"view",type:"function",returns:{sqrtPriceX96:"The current price of the pool as a sqrt(token1/token0) Q64.96 value tick The current tick of the pool, i.e. according to the last tick transition that was run. This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick boundary. observationIndex The index of the last oracle observation that was written, observationCardinality The current maximum number of observations stored in the pool, observationCardinalityNext The next maximum number of observations, to be updated when the observation. feeProtocol The protocol fee for both tokens of the pool. Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0 is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee. unlocked Whether the pool is currently locked to reentrancy"},notice:"The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas when accessed externally."},"tickBitmap(int16)":{inputs:[{internalType:"int16",name:"wordPosition",type:"int16"}],name:"tickBitmap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Returns 256 packed tick initialized boolean values. See TickBitmap for more information"},"ticks(int24)":{inputs:[{internalType:"int24",name:"tick",type:"int24"}],name:"ticks",outputs:[{internalType:"uint128",name:"liquidityGross",type:"uint128"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint256",name:"feeGrowthOutside0X128",type:"uint256"},{internalType:"uint256",name:"feeGrowthOutside1X128",type:"uint256"},{internalType:"int56",name:"tickCumulativeOutside",type:"int56"},{internalType:"uint160",name:"secondsPerLiquidityOutsideX128",type:"uint160"},{internalType:"uint32",name:"secondsOutside",type:"uint32"},{internalType:"bool",name:"initialized",type:"bool"}],stateMutability:"view",type:"function",params:{tick:"The tick to look up"},returns:{liquidityGross:"the total amount of position liquidity that uses the pool either as tick lower or tick upper, liquidityNet how much liquidity changes when the pool price crosses the tick, feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0, feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1, tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick, secondsOutside the seconds spent on the other side of the tick from the current tick, initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false. Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0. In addition, these values are only relative and must be used only in comparison to previous snapshots for a specific position."},notice:"Look up information about a specific tick in the pool"}}},"contracts/test/core/libraries/BitMath.sol:BitMath":{source:"contracts/test/core/libraries/BitMath.sol",name:"BitMath",title:"BitMath",details:"This library provides functionality for computing bit properties of an unsigned integer"},"contracts/test/core/libraries/FixedPoint128.sol:FixedPoint128":{source:"contracts/test/core/libraries/FixedPoint128.sol",name:"FixedPoint128",title:"FixedPoint128",notice:"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)"},"contracts/test/core/libraries/FixedPoint96.sol:FixedPoint96":{source:"contracts/test/core/libraries/FixedPoint96.sol",name:"FixedPoint96",title:"FixedPoint96",details:"Used in SqrtPriceMath.sol",notice:"A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)"},"contracts/test/core/libraries/FullMath.sol:FullMath":{source:"contracts/test/core/libraries/FullMath.sol",name:"FullMath",title:"Contains 512-bit math functions",details:'Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits',notice:"Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision"},"contracts/test/core/libraries/LiquidityMath.sol:LiquidityMath":{source:"contracts/test/core/libraries/LiquidityMath.sol",name:"LiquidityMath",title:"Math library for liquidity"},"contracts/test/core/libraries/LowGasSafeMath.sol:LowGasSafeMath":{source:"contracts/test/core/libraries/LowGasSafeMath.sol",name:"LowGasSafeMath",title:"Optimized overflow and underflow safe math operations",notice:"Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost"},"contracts/test/core/libraries/Oracle.sol:Oracle":{source:"contracts/test/core/libraries/Oracle.sol",name:"Oracle",title:"Oracle",details:'Instances of stored oracle data, "observations", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()',notice:"Provides price and liquidity data useful for a wide variety of system designs"},"contracts/test/core/libraries/Position.sol:Position":{source:"contracts/test/core/libraries/Position.sol",name:"Position",title:"Position",details:"Positions store additional state for tracking fees owed to the position",notice:"Positions represent an owner address' liquidity between a lower and upper tick boundary"},"contracts/test/core/libraries/SafeCast.sol:SafeCast":{source:"contracts/test/core/libraries/SafeCast.sol",name:"SafeCast",title:"Safe casting methods",notice:"Contains methods for safely casting between types"},"contracts/test/core/libraries/SqrtPriceMath.sol:SqrtPriceMath":{source:"contracts/test/core/libraries/SqrtPriceMath.sol",name:"SqrtPriceMath",title:"Functions based on Q64.96 sqrt price and liquidity",notice:"Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas"},"contracts/test/core/libraries/SwapMath.sol:SwapMath":{source:"contracts/test/core/libraries/SwapMath.sol",name:"SwapMath",title:"Computes the result of a swap within ticks",notice:"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick."},"contracts/test/core/libraries/Tick.sol:Tick":{source:"contracts/test/core/libraries/Tick.sol",name:"Tick",title:"Tick",notice:"Contains functions for managing tick processes and relevant calculations"},"contracts/test/core/libraries/TickBitmap.sol:TickBitmap":{source:"contracts/test/core/libraries/TickBitmap.sol",name:"TickBitmap",title:"Packed tick initialized state library",details:"The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.",notice:"Stores a packed mapping of tick index to its initialized state"},"contracts/test/core/libraries/TickMath.sol:TickMath":{source:"contracts/test/core/libraries/TickMath.sol",name:"TickMath",title:"Math library for computing sqrt prices from ticks and vice versa",notice:"Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports prices between 2**-128 and 2**128"},"contracts/test/core/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/test/core/libraries/TransferHelper.sol",name:"TransferHelper",title:"TransferHelper",notice:"Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false"},"contracts/test/core/libraries/UnsafeMath.sol:UnsafeMath":{source:"contracts/test/core/libraries/UnsafeMath.sol",name:"UnsafeMath",title:"Math functions that do not check inputs or outputs",notice:"Contains methods that perform common math functions but do not do any overflow or underflow checks"},"contracts/test/libraries/LiquidityHelperTest.sol:LiquidityHelperTest":{source:"contracts/test/libraries/LiquidityHelperTest.sol",name:"LiquidityHelperTest",methods:{"getAmountsForLiquidity(address,int24,int24,uint128)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"},{internalType:"uint128",name:"_liquidity",type:"uint128"}],name:"getAmountsForLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"view",type:"function",params:{_liquidity:"Liquidity of the pool",_pool:"Address of the pool",_tickLower:"Lower tick",_tickUpper:"Upper tick"},notice:"Calculates the liquidity amount using current ranges"},"getLiquidityForAmounts(address,int24,int24,uint256,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"int24",name:"_tickLower",type:"int24"},{internalType:"int24",name:"_tickUpper",type:"int24"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"}],name:"getLiquidityForAmounts",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"}],stateMutability:"view",type:"function",params:{_amount0:"Amount to be added for token0",_amount1:"Amount to be added for token1",_pool:"Pool address",_tickLower:"Lower tick",_tickUpper:"Upper tick"},returns:{liquidity:"Liquidity amount derived from token amounts"},notice:"Calculates the liquidity amount using current ranges"}}},"contracts/test/libraries/ShareHelperTest.sol:ShareHelperTest":{source:"contracts/test/libraries/ShareHelperTest.sol",name:"ShareHelperTest",methods:{"calculateShares(address,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"},{internalType:"uint256",name:"_totalShares",type:"uint256"}],name:"calculateShares",outputs:[{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculates the shares to be given for specific position",params:{_amount0:"Amount of token0",_amount1:"Amount of token1",_pool:"Address of the pool",_totalAmount0:"Total amount of token0",_totalAmount1:"Total amount of token1",_totalShares:"Total Number of shares"}}}},"contracts/test/libraries/TwapOracleLibraryTest.sol:TwapOracleLibraryTest":{source:"contracts/test/libraries/TwapOracleLibraryTest.sol",name:"TwapOracleLibraryTest",methods:{"BASE()":{inputs:[],name:"BASE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowSwap(address,address,uint256,uint256,address,address,address,bool[2])":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"address",name:"factory",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"address",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"}],name:"allowSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped",factory:"Address of the DefiEdge strategy factory",pool:"Address of the pool"},returns:{_0:"true if the swap is allowed, else false"},notice:"Checks for price slippage at the time of swap"},"getChainlinkPrice(address,address,address,uint256)":{inputs:[{internalType:"address",name:"registry",type:"address"},{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"},{internalType:"uint256",name:"_validPeriod",type:"uint256"}],name:"getChainlinkPrice",outputs:[{internalType:"uint256",name:"price",type:"uint256"}],stateMutability:"view",type:"function",params:{_base:"Base Asset",_quote:"Quote Asset",registry:"registry"},notice:"Returns latest Chainlink price, and normalise it"},"getPriceInUSD(address,address,address,address,bool[2],address)":{inputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"pool",type:"address"},{internalType:"address",name:"registry",type:"address"},{internalType:"address",name:"_priceOf",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{internalType:"address",name:"_manager",type:"address"}],name:"getPriceInUSD",outputs:[{internalType:"uint256",name:"price",type:"uint256"}],stateMutability:"view",type:"function",params:{_priceOf:"the token we want to convert into USD",pool:"Address of the Uniswap V3 pool",registry:"Interface of the Chainlink registry"},notice:"Gets latest Uniswap price in the pool, price of _token represented in USD"},"getUniswapPrice(address)":{inputs:[{internalType:"address",name:"pool",type:"address"}],name:"getUniswapPrice",outputs:[{internalType:"uint256",name:"price",type:"uint256"}],stateMutability:"view",type:"function",notice:"Gets latest Uniswap price in the pool, price of token1 represented in token0pool Address of the Uniswap V3 pool"},"isSwapExceedDeviation(address,address,address,uint256,uint256,address,address,address,bool[2])":{inputs:[{internalType:"address",name:"factory",type:"address"},{internalType:"address",name:"pool",type:"address"},{internalType:"address",name:"registry",type:"address"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"address",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"}],name:"isSwapExceedDeviation",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_manager:"Manager contract address to check allowed deviation",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped",pool:"Address of the pool",registry:"Chainlink registry interface"},notice:"Checks the if swap exceed allowed swap deviation or not"},"normalise(address,uint256)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"normalise",outputs:[{internalType:"uint256",name:"normalised",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/test/libraries/TwapShareHelperTest.sol:TwapShareHelperTest":{source:"contracts/test/libraries/TwapShareHelperTest.sol",name:"TwapShareHelperTest",methods:{"DIVISOR()":{inputs:[],name:"DIVISOR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateShares(address,address,address,address,bool[2],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_registry",type:"address"},{internalType:"address",name:"_pool",type:"address"},{internalType:"address",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"},{internalType:"uint256",name:"_totalShares",type:"uint256"}],name:"calculateShares",outputs:[{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculates the shares to be given for specific position",params:{_amount0:"Amount of token0",_amount1:"Amount of token1",_pool:"The token0",_registry:"Chainlink registry interface",_totalAmount0:"Total amount of token0",_totalAmount1:"Total amount of token1",_totalShares:"Total Number of shares"}},"getOptimalAmounts(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"}],name:"getOptimalAmounts",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"pure",type:"function"}}},"contracts/test/periphery/NonfungiblePositionManager.sol:NonfungiblePositionManager":{source:"contracts/test/periphery/NonfungiblePositionManager.sol",name:"NonfungiblePositionManager",title:"NFT positions",notice:"Wraps Uniswap V3 positions in the ERC721 non-fungible token interface",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"},{internalType:"address",name:"_tokenDescriptor_",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Collect(uint256,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Collect",type:"event",notice:"Emitted when tokens are collected for a position NFT"},"DecreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"DecreaseLiquidity",type:"event",notice:"Emitted when liquidity is decreased for a position NFT"},"IncreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"IncreaseLiquidity",type:"event",notice:"Emitted when liquidity is increased for a position NFT"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"The permit typehash used in the permit signature"},"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"baseURI()":{inputs:[],name:"baseURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",details:"Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"payable",type:"function",params:{tokenId:"The ID of the token that is being burned"},notice:"Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first."},"collect((uint256,address,uint128,uint128))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Max",type:"uint128"},{internalType:"uint128",name:"amount1Max",type:"uint128"}],internalType:"struct INonfungiblePositionManager.CollectParams",name:"params",type:"tuple"}],name:"collect",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the NFT for which tokens are being collected, recipient The account that should receive the tokens, amount0Max The maximum amount of token0 to collect, amount1Max The maximum amount of token1 to collect"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects up to a maximum amount of fees owed to a specific position to the recipient"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.DecreaseLiquidityParams",name:"params",type:"tuple"}],name:"decreaseLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being decreased, amount The amount by which liquidity will be decreased, amount0Min The minimum amount of token0 that should be accounted for the burned liquidity, amou`nt1Min The minimum amount of token1 that should be accounted for the burned liquidity, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 accounted to the position's tokens owed",amount1:"The amount of token1 accounted to the position's tokens owed"},notice:"Decreases the amount of liquidity in a position and accounts it to the position"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.IncreaseLiquidityParams",name:"params",type:"tuple"}],name:"increaseLiquidity",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being increased, amount0Desired The desired amount of token0 to be spent, amount1Desired The desired amount of token1 to be spent, amount0Min The minimum amount of token0 to spend, which serves as a slippage check, amount1Min The minimum amount of token1 to spend, which serves as a slippage check, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 to acheive resulting liquidity",amount1:"The amount of token1 to acheive resulting liquidity",liquidity:"The new liquidity amount as a result of the increase"},notice:"Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{inputs:[{components:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.MintParams",name:"params",type:"tuple"}],name:"mint",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",details:"Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.",params:{params:"The params necessary to mint a position, encoded as `MintParams` in calldata"},returns:{amount0:"The amount of token0",amount1:"The amount of token1",liquidity:"The amount of liquidity for this position",tokenId:"The ID of the token that represents the minted position"},notice:"Creates a new position wrapped in a NFT"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"positions(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"positions",outputs:[{internalType:"uint96",name:"nonce",type:"uint96"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",details:"Throws if the token ID is not valid.",params:{tokenId:"The ID of the token that represents the position"},returns:{fee:"The fee associated with the pool",feeGrowthInside0LastX128:"The fee growth of token0 as of the last action on the individual position",feeGrowthInside1LastX128:"The fee growth of token1 as of the last action on the individual position",liquidity:"The liquidity of the position",nonce:"The nonce for permits",operator:"The address that is approved for spending",tickLower:"The lower end of the tick range for the position",tickUpper:"The higher end of the tick range for the position",token0:"The address of the token0 for a specific pool",token1:"The address of the token1 for a specific pool",tokensOwed0:"The uncollected amount of token0 owed to the position as of the last computation",tokensOwed1:"The uncollected amount of token1 owed to the position as of the last computation"},notice:"Returns the position information associated with a given token ID."},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenByIndex}."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenOfOwnerByIndex}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-totalSupply}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/test/periphery/NonfungibleTokenPositionDescriptor.sol:NonfungibleTokenPositionDescriptor":{source:"contracts/test/periphery/NonfungibleTokenPositionDescriptor.sol",name:"NonfungibleTokenPositionDescriptor",title:"Describes NFT token positions",notice:"Produces a string containing the data URI for a JSON metadata string",constructor:{inputs:[{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"UpdateTokenRatioPriority(address,int256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"int256",name:"priority",type:"int256"}],name:"UpdateTokenRatioPriority",type:"event",notice:"Emitted when a token is given a new priority order in the displayed price ratio"}},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"flipRatio(address,address,uint256)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"}],name:"flipRatio",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"tokenRatioPriority(address,uint256)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"chainId",type:"uint256"}],name:"tokenRatioPriority",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"tokenURI(address,uint256)":{inputs:[{internalType:"contract INonfungiblePositionManager",name:"positionManager",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Note this URI may be a data: URI with the JSON contents directly inlined",params:{positionManager:"The position manager for which to describe the token",tokenId:"The ID of the token for which to produce a description, which may not be valid"},returns:{_0:"The URI of the ERC721-compliant metadata"},notice:"Produces the URI describing a particular token ID for a position manager"}}},"contracts/test/periphery/SwapRouter.sol:IUniswapV3Factory":{source:"contracts/test/periphery/SwapRouter.sol",name:"IUniswapV3Factory",methods:{"getPool(address,address,uint24)":{inputs:[{internalType:"address",name:"tokenA",type:"address"},{internalType:"address",name:"tokenB",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"}],name:"getPool",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/test/periphery/SwapRouter.sol:SwapRouter":{source:"contracts/test/periphery/SwapRouter.sol",name:"SwapRouter",title:"Uniswap V3 Swap Router",notice:"Router for stateless execution of swaps against Uniswap V3",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"exactInput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"}],internalType:"struct ISwapRouter.ExactInputParams",name:"params",type:"tuple"}],name:"exactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another along the specified path"},"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactInputSingleParams",name:"params",type:"tuple"}],name:"exactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another token"},"exactOutput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"}],internalType:"struct ISwapRouter.ExactOutputParams",name:"params",type:"tuple"}],name:"exactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)"},"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactOutputSingleParams",name:"params",type:"tuple"}],name:"exactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another token"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/test/periphery/V3Migrator.sol:V3Migrator":{source:"contracts/test/periphery/V3Migrator.sol",name:"V3Migrator",title:"Uniswap V3 Migrator",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"},{internalType:"address",name:"_nonfungiblePositionManager",type:"address"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"migrate((address,uint256,uint8,address,address,uint24,int24,int24,uint256,uint256,address,uint256,bool))":{inputs:[{components:[{internalType:"address",name:"pair",type:"address"},{internalType:"uint256",name:"liquidityToMigrate",type:"uint256"},{internalType:"uint8",name:"percentageToMigrate",type:"uint8"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"refundAsETH",type:"bool"}],internalType:"struct IV3Migrator.MigrateParams",name:"params",type:"tuple"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range",params:{params:"The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata"},notice:"Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"nonfungiblePositionManager()":{inputs:[],name:"nonfungiblePositionManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/test/periphery/base/BlockTimestamp.sol:BlockTimestamp":{source:"contracts/test/periphery/base/BlockTimestamp.sol",name:"BlockTimestamp",title:"Function for getting block timestamp",details:"Base contract that is overridden for tests"},"contracts/test/periphery/base/ERC721Permit.sol:ERC721Permit":{source:"contracts/test/periphery/base/ERC721Permit.sol",name:"ERC721Permit",title:"ERC721 with permit",notice:"Nonfungible tokens that support an approve via signature, i.e. permit",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},stateVariables:{"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:'Value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)");',return:"The typehash for the permit",notice:"The permit typehash used in the permit signature"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"baseURI()":{inputs:[],name:"baseURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenByIndex}."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-tokenOfOwnerByIndex}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-tokenURI}."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721Enumerable-totalSupply}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"contracts/test/periphery/base/LiquidityManagement.sol:LiquidityManagement":{source:"contracts/test/periphery/base/LiquidityManagement.sol",name:"LiquidityManagement",title:"Liquidity management functions",notice:"Internal functions for safely managing liquidity in Uniswap V3",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0Owed",type:"uint256"},{internalType:"uint256",name:"amount1Owed",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the minted liquidity. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.",params:{amount0Owed:"The amount of token0 due to the pool for the minted liquidity",amount1Owed:"The amount of token1 due to the pool for the minted liquidity",data:"Any data passed through by the caller via the IUniswapV3PoolActions#mint call"},notice:"Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/test/periphery/base/Multicall.sol:Multicall":{source:"contracts/test/periphery/base/Multicall.sol",name:"Multicall",title:"Multicall",notice:"Enables calling multiple methods in a single call to the contract",methods:{"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"}}},"contracts/test/periphery/base/PeripheryImmutableState.sol:PeripheryImmutableState":{source:"contracts/test/periphery/base/PeripheryImmutableState.sol",name:"PeripheryImmutableState",title:"Immutable state",notice:"Immutable state used by periphery contracts",stateVariables:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"Returns the address of WETH9"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",return:"Returns the address of the Uniswap V3 factory"}}},"contracts/test/periphery/base/PeripheryPayments.sol:PeripheryPayments":{source:"contracts/test/periphery/base/PeripheryPayments.sol",name:"PeripheryPayments",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/test/periphery/base/PeripheryPaymentsWithFee.sol:PeripheryPaymentsWithFee":{source:"contracts/test/periphery/base/PeripheryPaymentsWithFee.sol",name:"PeripheryPaymentsWithFee",receive:{stateMutability:"payable",type:"receive"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/test/periphery/base/PeripheryValidation.sol:PeripheryValidation":{source:"contracts/test/periphery/base/PeripheryValidation.sol",name:"PeripheryValidation"},"contracts/test/periphery/base/PoolInitializer.sol:PoolInitializer":{source:"contracts/test/periphery/base/PoolInitializer.sol",name:"PoolInitializer",title:"Creates and initializes V3 Pools",methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/test/periphery/base/SelfPermit.sol:SelfPermit":{source:"contracts/test/periphery/base/SelfPermit.sol",name:"SelfPermit",title:"Self Permit",details:"These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function that requires an approval in a single transaction.",notice:"Functionality to call permit on any EIP-2612-compliant token for use in the route",methods:{"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/test/periphery/interfaces/IERC20Metadata.sol:IERC20Metadata":{source:"contracts/test/periphery/interfaces/IERC20Metadata.sol",name:"IERC20Metadata",title:"IERC20MetadataInterface for ERC20 Metadata",notice:"Extension to IERC20 that includes token metadata",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"The number of decimal places the token has"}},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",returns:{_0:"The name of the token"}},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",returns:{_0:"The symbol of the token"}},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/test/periphery/interfaces/IERC721Permit.sol:IERC721Permit":{source:"contracts/test/periphery/interfaces/IERC721Permit.sol",name:"IERC721Permit",title:"ERC721 with permit",notice:"Extension to ERC721 that includes a permit function for signature based approvals",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",returns:{_0:"The typehash for the permit"},notice:"The permit typehash used in the permit signature"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"contracts/test/periphery/interfaces/IMulticall.sol:IMulticall":{source:"contracts/test/periphery/interfaces/IMulticall.sol",name:"IMulticall",title:"Multicall interface",notice:"Enables calling multiple methods in a single call to the contract",methods:{"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"}}},"contracts/test/periphery/interfaces/INonfungiblePositionManager.sol:INonfungiblePositionManager":{source:"contracts/test/periphery/interfaces/INonfungiblePositionManager.sol",name:"INonfungiblePositionManager",title:"Non-fungible token for positions",notice:"Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred and authorized.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Collect(uint256,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"recipient",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Collect",type:"event",details:"The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior",params:{amount0:"The amount of token0 owed to the position that was collected",amount1:"The amount of token1 owed to the position that was collected",recipient:"The address of the account that received the collected tokens",tokenId:"The ID of the token for which underlying tokens were collected"},notice:"Emitted when tokens are collected for a position NFT"},"DecreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"DecreaseLiquidity",type:"event",params:{amount0:"The amount of token0 that was accounted for the decrease in liquidity",amount1:"The amount of token1 that was accounted for the decrease in liquidity",liquidity:"The amount by which liquidity for the NFT position was decreased",tokenId:"The ID of the token for which liquidity was decreased"},notice:"Emitted when liquidity is decreased for a position NFT"},"IncreaseLiquidity(uint256,uint128,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"uint128",name:"liquidity",type:"uint128"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"IncreaseLiquidity",type:"event",details:"Also emitted when a token is minted",params:{amount0:"The amount of token0 that was paid for the increase in liquidity",amount1:"The amount of token1 that was paid for the increase in liquidity",liquidity:"The amount by which liquidity for the NFT position was increased",tokenId:"The ID of the token for which liquidity was increased"},notice:"Emitted when liquidity is increased for a position NFT"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",returns:{_0:"The domain seperator used in encoding of permit signature"},notice:"The domain separator used in the permit signature"},"PERMIT_TYPEHASH()":{inputs:[],name:"PERMIT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function",returns:{_0:"The typehash for the permit"},notice:"The permit typehash used in the permit signature"},"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of WETH9"}},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"payable",type:"function",params:{tokenId:"The ID of the token that is being burned"},notice:"Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens must be collected first."},"collect((uint256,address,uint128,uint128))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint128",name:"amount0Max",type:"uint128"},{internalType:"uint128",name:"amount1Max",type:"uint128"}],internalType:"struct INonfungiblePositionManager.CollectParams",name:"params",type:"tuple"}],name:"collect",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the NFT for which tokens are being collected, recipient The account that should receive the tokens, amount0Max The maximum amount of token0 to collect, amount1Max The maximum amount of token1 to collect"},returns:{amount0:"The amount of fees collected in token0",amount1:"The amount of fees collected in token1"},notice:"Collects up to a maximum amount of fees owed to a specific position to the recipient"},"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.DecreaseLiquidityParams",name:"params",type:"tuple"}],name:"decreaseLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being decreased, amount The amount by which liquidity will be decreased, amount0Min The minimum amount of token0 that should be accounted for the burned liquidity, amou`nt1Min The minimum amount of token1 that should be accounted for the burned liquidity, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 accounted to the position's tokens owed",amount1:"The amount of token1 accounted to the position's tokens owed"},notice:"Decreases the amount of liquidity in a position and accounts it to the position"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of the Uniswap V3 factory"}},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.IncreaseLiquidityParams",name:"params",type:"tuple"}],name:"increaseLiquidity",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"tokenId The ID of the token for which liquidity is being increased, amount0Desired The desired amount of token0 to be spent, amount1Desired The desired amount of token1 to be spent, amount0Min The minimum amount of token0 to spend, which serves as a slippage check, amount1Min The minimum amount of token1 to spend, which serves as a slippage check, deadline The time by which the transaction must be included to effect the change"},returns:{amount0:"The amount of token0 to acheive resulting liquidity",amount1:"The amount of token1 to acheive resulting liquidity",liquidity:"The new liquidity amount as a result of the increase"},notice:"Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{inputs:[{components:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Desired",type:"uint256"},{internalType:"uint256",name:"amount1Desired",type:"uint256"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"}],internalType:"struct INonfungiblePositionManager.MintParams",name:"params",type:"tuple"}],name:"mint",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"payable",type:"function",details:"Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized.",params:{params:"The params necessary to mint a position, encoded as `MintParams` in calldata"},returns:{amount0:"The amount of token0",amount1:"The amount of token1",liquidity:"The amount of liquidity for this position",tokenId:"The ID of the token that represents the minted position"},notice:"Creates a new position wrapped in a NFT"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"permit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"payable",type:"function",params:{deadline:"The deadline timestamp by which the call must be mined for the approve to work",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The account that is being approved",tokenId:"The ID of the token that is being approved for spending",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve of a specific token ID for spending by spender via signature"},"positions(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"positions",outputs:[{internalType:"uint96",name:"nonce",type:"uint96"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint128",name:"liquidity",type:"uint128"},{internalType:"uint256",name:"feeGrowthInside0LastX128",type:"uint256"},{internalType:"uint256",name:"feeGrowthInside1LastX128",type:"uint256"},{internalType:"uint128",name:"tokensOwed0",type:"uint128"},{internalType:"uint128",name:"tokensOwed1",type:"uint128"}],stateMutability:"view",type:"function",details:"Throws if the token ID is not valid.",params:{tokenId:"The ID of the token that represents the position"},returns:{fee:"The fee associated with the pool",feeGrowthInside0LastX128:"The fee growth of token0 as of the last action on the individual position",feeGrowthInside1LastX128:"The fee growth of token1 as of the last action on the individual position",liquidity:"The liquidity of the position",nonce:"The nonce for permits",operator:"The address that is approved for spending",tickLower:"The lower end of the tick range for the position",tickUpper:"The higher end of the tick range for the position",token0:"The address of the token0 for a specific pool",token1:"The address of the token1 for a specific pool",tokensOwed0:"The uncollected amount of token0 owed to the position as of the last computation",tokensOwed1:"The uncollected amount of token1 owed to the position as of the last computation"},notice:"Returns the position information associated with a given token ID."},"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenByIndex(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenByIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."},"tokenOfOwnerByIndex(address,uint256)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"uint256",name:"index",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the Uniform Resource Identifier (URI) for `tokenId` token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the total amount of tokens stored by the contract."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/test/periphery/interfaces/INonfungibleTokenPositionDescriptor.sol:INonfungibleTokenPositionDescriptor":{source:"contracts/test/periphery/interfaces/INonfungibleTokenPositionDescriptor.sol",name:"INonfungibleTokenPositionDescriptor",title:"Describes position NFT tokens via URI",events:{"UpdateTokenRatioPriority(address,int256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"int256",name:"priority",type:"int256"}],name:"UpdateTokenRatioPriority",type:"event",params:{priority:"Represents priority in ratio - higher integers get numerator priority",token:"The token being given priority order"},notice:"Emitted when a token is given a new priority order in the displayed price ratio"}},methods:{"tokenURI(address,uint256)":{inputs:[{internalType:"contract INonfungiblePositionManager",name:"positionManager",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Note this URI may be a data: URI with the JSON contents directly inlined",params:{positionManager:"The position manager for which to describe the token",tokenId:"The ID of the token for which to produce a description, which may not be valid"},returns:{_0:"The URI of the ERC721-compliant metadata"},notice:"Produces the URI describing a particular token ID for a position manager"}}},"contracts/test/periphery/interfaces/IPeripheryImmutableState.sol:IPeripheryImmutableState":{source:"contracts/test/periphery/interfaces/IPeripheryImmutableState.sol",name:"IPeripheryImmutableState",title:"Immutable state",notice:"Functions that return immutable state of the router",methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of WETH9"}},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",returns:{_0:"Returns the address of the Uniswap V3 factory"}}}},"contracts/test/periphery/interfaces/IPeripheryPayments.sol:IPeripheryPayments":{source:"contracts/test/periphery/interfaces/IPeripheryPayments.sol",name:"IPeripheryPayments",title:"Periphery Payments",notice:"Functions to ease deposits and withdrawals of ETH",methods:{"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."}}},"contracts/test/periphery/interfaces/IPeripheryPaymentsWithFee.sol:IPeripheryPaymentsWithFee":{source:"contracts/test/periphery/interfaces/IPeripheryPaymentsWithFee.sol",name:"IPeripheryPaymentsWithFee",title:"Periphery Payments",notice:"Functions to ease deposits and withdrawals of ETH",methods:{"refundETH()":{inputs:[],name:"refundETH",outputs:[],stateMutability:"payable",type:"function",details:"Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps that use ether for the input amount",notice:"Refunds any ETH balance held by this contract to the `msg.sender`"},"sweepToken(address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"sweepToken",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",params:{amountMinimum:"The minimum amount of token required for a transfer",recipient:"The destination address of the token",token:"The contract address of the token which will be transferred to `recipient`"},notice:"Transfers the full amount of a token held by this contract to recipient"},"sweepTokenWithFee(address,uint256,address,uint256,address)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"sweepTokenWithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing the token from users",notice:"Transfers the full amount of a token held by this contract to recipient, with a percentage between 0 (exclusive) and 1 (inclusive) going to feeRecipient"},"unwrapWETH9(uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"}],name:"unwrapWETH9",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",params:{amountMinimum:"The minimum amount of WETH9 to unwrap",recipient:"The address receiving ETH"},notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH."},"unwrapWETH9WithFee(uint256,address,uint256,address)":{inputs:[{internalType:"uint256",name:"amountMinimum",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"feeBips",type:"uint256"},{internalType:"address",name:"feeRecipient",type:"address"}],name:"unwrapWETH9WithFee",outputs:[],stateMutability:"payable",type:"function",details:"The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.",notice:"Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between 0 (exclusive), and 1 (inclusive) going to feeRecipient"}}},"contracts/test/periphery/interfaces/IPoolInitializer.sol:IPoolInitializer":{source:"contracts/test/periphery/interfaces/IPoolInitializer.sol",name:"IPoolInitializer",title:"Creates and initializes V3 Pools",notice:"Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that require the pool to exist.",methods:{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"}}},"contracts/test/periphery/interfaces/IQuoter.sol:IQuoter":{source:"contracts/test/periphery/interfaces/IQuoter.sol",name:"IQuoter",title:"Quoter Interface",details:"These functions are not marked view because they rely on calling non-view functions and reverting to compute the result. They are also not gas efficient and should not be called on-chain.",notice:"Supports quoting the calculated amounts from exact input or exact output swaps",methods:{"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The desired input amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountOut:"The amount of `tokenOut` that would be received"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountIn:"The amount of first token required to be paid"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The desired output amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"}}},"contracts/test/periphery/interfaces/ISelfPermit.sol:ISelfPermit":{source:"contracts/test/periphery/interfaces/ISelfPermit.sol",name:"ISelfPermit",title:"Self Permit",notice:"Functionality to call permit on any EIP-2612-compliant token for use in the route",methods:{"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/test/periphery/interfaces/ISwapRouter.sol:ISwapRouter":{source:"contracts/test/periphery/interfaces/ISwapRouter.sol",name:"ISwapRouter",title:"Router token swapping functionality",notice:"Functions for swapping tokens via Uniswap V3",methods:{"exactInput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"}],internalType:"struct ISwapRouter.ExactInputParams",name:"params",type:"tuple"}],name:"exactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another along the specified path"},"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint256",name:"amountOutMinimum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactInputSingleParams",name:"params",type:"tuple"}],name:"exactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata"},returns:{amountOut:"The amount of the received token"},notice:"Swaps `amountIn` of one token for as much as possible of another token"},"exactOutput((bytes,address,uint256,uint256,uint256))":{inputs:[{components:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"}],internalType:"struct ISwapRouter.ExactOutputParams",name:"params",type:"tuple"}],name:"exactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)"},"exactOutputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))":{inputs:[{components:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint256",name:"amountInMaximum",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],internalType:"struct ISwapRouter.ExactOutputSingleParams",name:"params",type:"tuple"}],name:"exactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"payable",type:"function",params:{params:"The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata"},returns:{amountIn:"The amount of the input token"},notice:"Swaps as little as possible of one token for `amountOut` of another token"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/test/periphery/interfaces/ITickLens.sol:ITickLens":{source:"contracts/test/periphery/interfaces/ITickLens.sol",name:"ITickLens",title:"Tick Lens",details:"This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and then sending additional multicalls to fetch the tick data",notice:"Provides functions for fetching chunks of tick data for a pool",methods:{"getPopulatedTicksInWord(address,int16)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"int16",name:"tickBitmapIndex",type:"int16"}],name:"getPopulatedTicksInWord",outputs:[{components:[{internalType:"int24",name:"tick",type:"int24"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint128",name:"liquidityGross",type:"uint128"}],internalType:"struct ITickLens.PopulatedTick[]",name:"populatedTicks",type:"tuple[]"}],stateMutability:"view",type:"function",params:{pool:"The address of the pool for which to fetch populated tick data",tickBitmapIndex:"The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks"},returns:{populatedTicks:"An array of tick data for the given word in the tick bitmap"},notice:"Get all the tick data for the populated ticks from a word of the tick bitmap of a pool"}}},"contracts/test/periphery/interfaces/IV3Migrator.sol:IV3Migrator":{source:"contracts/test/periphery/interfaces/IV3Migrator.sol",name:"IV3Migrator",title:"V3 Migrator",notice:"Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools",methods:{"createAndInitializePoolIfNecessary(address,address,uint24,uint160)":{inputs:[{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint160",name:"sqrtPriceX96",type:"uint160"}],name:"createAndInitializePoolIfNecessary",outputs:[{internalType:"address",name:"pool",type:"address"}],stateMutability:"payable",type:"function",details:"This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool",params:{fee:"The fee amount of the v3 pool for the specified token pair",sqrtPriceX96:"The initial square root price of the pool as a Q64.96 value",token0:"The contract address of token0 of the pool",token1:"The contract address of token1 of the pool"},returns:{pool:"Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary"},notice:"Creates a new pool if it does not exist, then initializes if not initialized"},"migrate((address,uint256,uint8,address,address,uint24,int24,int24,uint256,uint256,address,uint256,bool))":{inputs:[{components:[{internalType:"address",name:"pair",type:"address"},{internalType:"uint256",name:"liquidityToMigrate",type:"uint256"},{internalType:"uint8",name:"percentageToMigrate",type:"uint8"},{internalType:"address",name:"token0",type:"address"},{internalType:"address",name:"token1",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0Min",type:"uint256"},{internalType:"uint256",name:"amount1Min",type:"uint256"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"bool",name:"refundAsETH",type:"bool"}],internalType:"struct IV3Migrator.MigrateParams",name:"params",type:"tuple"}],name:"migrate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range",params:{params:"The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata"},notice:"Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3"},"multicall(bytes[])":{inputs:[{internalType:"bytes[]",name:"data",type:"bytes[]"}],name:"multicall",outputs:[{internalType:"bytes[]",name:"results",type:"bytes[]"}],stateMutability:"payable",type:"function",details:"The `msg.value` should not be trusted for any method callable from multicall.",params:{data:"The encoded function data for each of the calls to make to this contract"},returns:{results:"The results from each of the calls passed in via data"},notice:"Call multiple functions in the current contract and return the data from all of them if they all succeed"},"selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermit",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this).",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"},"selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowed",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this)",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitAllowedIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this) Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.",params:{expiry:"The timestamp at which the permit is no longer valid",nonce:"The current nonce of the owner",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter"},"selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"selfPermitIfNecessary",outputs:[],stateMutability:"payable",type:"function",details:"The `owner` is always msg.sender and the `spender` is always address(this). Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit",params:{deadline:"A timestamp, the current blocktime must be less than or equal to this timestamp",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",token:"The address of the token spent",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`",value:"The amount that can be spent of token"},notice:"Permits this contract to spend a given token from `msg.sender`"}}},"contracts/test/periphery/interfaces/external/IERC1271.sol:IERC1271":{source:"contracts/test/periphery/interfaces/external/IERC1271.sol",name:"IERC1271",title:"Interface for verifying contract-based account signatures",details:"Interface defined by EIP-1271",notice:"Interface that verifies provided signature for the data",methods:{"isValidSignature(bytes32,bytes)":{inputs:[{internalType:"bytes32",name:"hash",type:"bytes32"},{internalType:"bytes",name:"signature",type:"bytes"}],name:"isValidSignature",outputs:[{internalType:"bytes4",name:"magicValue",type:"bytes4"}],stateMutability:"view",type:"function",details:"MUST return the bytes4 magic value 0x1626ba7e when function passes. MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5). MUST allow external calls.",params:{hash:"Hash of the data to be signed",signature:"Signature byte array associated with _data"},returns:{magicValue:"The bytes4 magic value 0x1626ba7e"},notice:"Returns whether the provided signature is valid for the provided data"}}},"contracts/test/periphery/interfaces/external/IERC20PermitAllowed.sol:IERC20PermitAllowed":{source:"contracts/test/periphery/interfaces/external/IERC20PermitAllowed.sol",name:"IERC20PermitAllowed",title:"Interface for permit",notice:"Interface used by DAI/CHAI for permit",methods:{"permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"holder",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"bool",name:"allowed",type:"bool"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"This is the permit interface used by DAI and CHAI",params:{allowed:"Boolean that sets approval amount, true for type(uint256).max and false for 0",expiry:"The timestamp at which the permit is no longer valid",holder:"The address of the token holder, the token owner",nonce:"The holder's nonce, increases at each call to permit",r:"Must produce valid secp256k1 signature from the holder along with `v` and `s`",s:"Must produce valid secp256k1 signature from the holder along with `r` and `v`",spender:"The address of the token spender",v:"Must produce valid secp256k1 signature from the holder along with `r` and `s`"},notice:"Approve the spender to spend some tokens via the holder signature"}}},"contracts/test/periphery/interfaces/external/IWETH9.sol:IWETH9":{source:"contracts/test/periphery/interfaces/external/IWETH9.sol",name:"IWETH9",title:"Interface for WETH9",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function",notice:"Deposit ether to get wrapped ether"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Withdraw wrapped ether to get ether"}}},"contracts/test/periphery/lens/Quoter.sol:Quoter":{source:"contracts/test/periphery/lens/Quoter.sol",name:"Quoter",title:"Provides quotes for swaps",details:"These functions are not gas efficient and should _not_ be called on chain. Instead, optimistically execute the swap and check the amounts in the callback.",notice:"Allows getting the expected amount out or amount in for a given swap without executing the swap",constructor:{inputs:[{internalType:"address",name:"_factory",type:"address"},{internalType:"address",name:"_WETH9",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"WETH9()":{inputs:[],name:"WETH9",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"quoteExactInput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountIn",type:"uint256"}],name:"quoteExactInput",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The amount of the first token to swap",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountOut:"The amount of the last token that would be received"},notice:"Returns the amount out received for a given exact input swap without executing the swap"},"quoteExactInputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountIn",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactInputSingle",outputs:[{internalType:"uint256",name:"amountOut",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountIn:"The desired input amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountOut:"The amount of `tokenOut` that would be received"},notice:"Returns the amount out received for a given exact input but for a swap of a single pool"},"quoteExactOutput(bytes,uint256)":{inputs:[{internalType:"bytes",name:"path",type:"bytes"},{internalType:"uint256",name:"amountOut",type:"uint256"}],name:"quoteExactOutput",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The amount of the last token to receive",path:"The path of the swap, i.e. each token pair and the pool fee"},returns:{amountIn:"The amount of first token required to be paid"},notice:"Returns the amount in required for a given exact output swap without executing the swap"},"quoteExactOutputSingle(address,address,uint24,uint256,uint160)":{inputs:[{internalType:"address",name:"tokenIn",type:"address"},{internalType:"address",name:"tokenOut",type:"address"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"uint256",name:"amountOut",type:"uint256"},{internalType:"uint160",name:"sqrtPriceLimitX96",type:"uint160"}],name:"quoteExactOutputSingle",outputs:[{internalType:"uint256",name:"amountIn",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{amountOut:"The desired output amount",fee:"The fee of the token pool to consider for the pair",sqrtPriceLimitX96:"The price limit of the pool that cannot be exceeded by the swap",tokenIn:"The token being swapped in",tokenOut:"The token being swapped out"},returns:{amountIn:"The amount required as the input for the swap in order to receive `amountOut`"},notice:"Returns the amount in required to receive the given exact output amount but for a swap of a single pool"},"uniswapV3SwapCallback(int256,int256,bytes)":{inputs:[{internalType:"int256",name:"amount0Delta",type:"int256"},{internalType:"int256",name:"amount1Delta",type:"int256"},{internalType:"bytes",name:"path",type:"bytes"}],name:"uniswapV3SwapCallback",outputs:[],stateMutability:"view",type:"function",details:"In the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.",params:{amount0Delta:"The amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.",amount1Delta:"The amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.",data:"Any data passed through by the caller via the IUniswapV3PoolActions#swap call"},notice:"Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap."}}},"contracts/test/periphery/lens/TickLens.sol:TickLens":{source:"contracts/test/periphery/lens/TickLens.sol",name:"TickLens",title:"Tick Lens contract",methods:{"getPopulatedTicksInWord(address,int16)":{inputs:[{internalType:"address",name:"pool",type:"address"},{internalType:"int16",name:"tickBitmapIndex",type:"int16"}],name:"getPopulatedTicksInWord",outputs:[{components:[{internalType:"int24",name:"tick",type:"int24"},{internalType:"int128",name:"liquidityNet",type:"int128"},{internalType:"uint128",name:"liquidityGross",type:"uint128"}],internalType:"struct ITickLens.PopulatedTick[]",name:"populatedTicks",type:"tuple[]"}],stateMutability:"view",type:"function",params:{pool:"The address of the pool for which to fetch populated tick data",tickBitmapIndex:"The index of the word in the tick bitmap for which to parse the bitmap and fetch all the populated ticks"},returns:{populatedTicks:"An array of tick data for the given word in the tick bitmap"},notice:"Get all the tick data for the populated ticks from a word of the tick bitmap of a pool"}}},"contracts/test/periphery/libraries/BytesLib.sol:BytesLib":{source:"contracts/test/periphery/libraries/BytesLib.sol",name:"BytesLib"},"contracts/test/periphery/libraries/CallbackValidation.sol:CallbackValidation":{source:"contracts/test/periphery/libraries/CallbackValidation.sol",name:"CallbackValidation",notice:"Provides validation for callbacks from Uniswap V3 Pools"},"contracts/test/periphery/libraries/ChainId.sol:ChainId":{source:"contracts/test/periphery/libraries/ChainId.sol",name:"ChainId",title:"Function for getting the current chain ID"},"contracts/test/periphery/libraries/HexStrings.sol:HexStrings":{source:"contracts/test/periphery/libraries/HexStrings.sol",name:"HexStrings"},"contracts/test/periphery/libraries/LiquidityAmounts.sol:LiquidityAmounts":{source:"contracts/test/periphery/libraries/LiquidityAmounts.sol",name:"LiquidityAmounts",title:"Liquidity amount functions",notice:"Provides functions for computing liquidity amounts from token amounts and prices",methods:{"getAmountsForLiquidity(uint160,uint160,uint160,uint128)":{inputs:[{internalType:"uint160",name:"sqrtRatioX96",type:"uint160"},{internalType:"uint160",name:"sqrtRatioAX96",type:"uint160"},{internalType:"uint160",name:"sqrtRatioBX96",type:"uint160"},{internalType:"uint128",name:"liquidity",type:"uint128"}],name:"getAmountsForLiquidity",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"pure",type:"function",params:{liquidity:"The liquidity being valued",sqrtRatioAX96:"A sqrt price representing the first tick boundary",sqrtRatioBX96:"A sqrt price representing the second tick boundary",sqrtRatioX96:"A sqrt price representing the current pool prices"},returns:{amount0:"The amount of token0",amount1:"The amount of token1"},notice:"Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries"},"getLiquidityForAmounts(uint160,uint160,uint160,uint256,uint256)":{inputs:[{internalType:"uint160",name:"sqrtRatioX96",type:"uint160"},{internalType:"uint160",name:"sqrtRatioAX96",type:"uint160"},{internalType:"uint160",name:"sqrtRatioBX96",type:"uint160"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],name:"getLiquidityForAmounts",outputs:[{internalType:"uint128",name:"liquidity",type:"uint128"}],stateMutability:"view",type:"function",params:{amount0:"The amount of token0 being sent in",amount1:"The amount of token1 being sent in",sqrtRatioAX96:"A sqrt price representing the first tick boundary",sqrtRatioBX96:"A sqrt price representing the second tick boundary",sqrtRatioX96:"A sqrt price representing the current pool prices"},returns:{liquidity:"The maximum amount of liquidity received"},notice:"Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries"}}},"contracts/test/periphery/libraries/NFTDescriptor.sol:NFTDescriptor":{source:"contracts/test/periphery/libraries/NFTDescriptor.sol",name:"NFTDescriptor",methods:{"constructTokenURI((uint256,address,address,string,string,uint8,uint8,bool,int24,int24,int24,int24,uint24,address))":{inputs:[{components:[{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"quoteTokenAddress",type:"address"},{internalType:"address",name:"baseTokenAddress",type:"address"},{internalType:"string",name:"quoteTokenSymbol",type:"string"},{internalType:"string",name:"baseTokenSymbol",type:"string"},{internalType:"uint8",name:"quoteTokenDecimals",type:"uint8"},{internalType:"uint8",name:"baseTokenDecimals",type:"uint8"},{internalType:"bool",name:"flipRatio",type:"bool"},{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"int24",name:"tickCurrent",type:"int24"},{internalType:"int24",name:"tickSpacing",type:"int24"},{internalType:"uint24",name:"fee",type:"uint24"},{internalType:"address",name:"poolAddress",type:"address"}],internalType:"struct NFTDescriptor.ConstructTokenURIParams",name:"params",type:"tuple"}],name:"constructTokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function"}}},"contracts/test/periphery/libraries/NFTSVG.sol:NFTSVG":{source:"contracts/test/periphery/libraries/NFTSVG.sol",name:"NFTSVG",title:"NFTSVG",notice:"Provides a function for generating an SVG associated with a Uniswap NFT"},"contracts/test/periphery/libraries/Path.sol:Path":{source:"contracts/test/periphery/libraries/Path.sol",name:"Path",title:"Functions for manipulating path data for multihop swaps"},"contracts/test/periphery/libraries/PoolAddress.sol:PoolAddress":{source:"contracts/test/periphery/libraries/PoolAddress.sol",name:"PoolAddress",title:"Provides functions for deriving a pool address from the factory, tokens, and the fee"},"contracts/test/periphery/libraries/PositionKey.sol:PositionKey":{source:"contracts/test/periphery/libraries/PositionKey.sol",name:"PositionKey"},"contracts/test/periphery/libraries/TokenRatioSortOrder.sol:TokenRatioSortOrder":{source:"contracts/test/periphery/libraries/TokenRatioSortOrder.sol",name:"TokenRatioSortOrder"},"contracts/test/periphery/libraries/TransferHelper.sol:TransferHelper":{source:"contracts/test/periphery/libraries/TransferHelper.sol",name:"TransferHelper"},"contracts/twap/DefiEdgeTwapStrategy.sol:DefiEdgeTwapStrategy":{source:"contracts/twap/DefiEdgeTwapStrategy.sol",name:"DefiEdgeTwapStrategy",constructor:{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_oneInchRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Burn(address,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"share",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Burn",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"Hold()":{anonymous:!1,inputs:[],name:"Hold",type:"event"},"Mint(address,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"share",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"Mint",type:"event"},"PartialRebalance((uint256,bool,uint256,uint256)[])":{anonymous:!1,inputs:[{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],indexed:!1,internalType:"struct DefiEdgeTwapStrategy.PartialTick[]",name:"ticks",type:"tuple[]"}],name:"PartialRebalance",type:"event"},"Rebalance((int24,int24,uint256,uint256)[])":{anonymous:!1,inputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],indexed:!1,internalType:"struct DefiEdgeTwapStrategy.NewTick[]",name:"ticks",type:"tuple[]"}],name:"Rebalance",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burn(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_shares",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"}],name:"burn",outputs:[{internalType:"uint256",name:"collect0",type:"uint256"},{internalType:"uint256",name:"collect1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_amount0Min:"Mimimum amount of token0 to be received",_amount1Min:"Minimum amount of token1 to be received",_shares:"Shares to be burned"},notice:"Burn liquidity and transfer tokens back to the user"},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},notice:"Burn liquidity from specific tick"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"emergencyWithdraw(address,address,uint256)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_to",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"emergencyWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAUMWithFees(bool)":{inputs:[{internalType:"bool",name:"_includeFee",type:"bool"}],name:"getAUMWithFees",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"totalFee0",type:"uint256"},{internalType:"uint256",name:"totalFee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_includeFee:"Whether to include pool fees in AUM or not. (passing true will also collect fees from pool)"},notice:"Get's assets under management with realtime fees"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract ITwapStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"mint(uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"},{internalType:"uint256",name:"_minShare",type:"uint256"}],name:"mint",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_amount0:"Amount of token0",_amount0Min:"Minimum amount of token0 to be minted",_amount1:"Amount of token1",_amount1Min:"Minimum amount of token1 to be minted",_minShare:"Minimum amount of shares to be received to the user"},notice:"Adds liquidity to the primary range"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"rebalance(bytes,(uint256,bool,uint256,uint256)[],(int24,int24,uint256,uint256)[],bool)":{inputs:[{internalType:"bytes",name:"_swapData",type:"bytes"},{components:[{internalType:"uint256",name:"index",type:"uint256"},{internalType:"bool",name:"burn",type:"bool"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgeTwapStrategy.PartialTick[]",name:"_existingTicks",type:"tuple[]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"},{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],internalType:"struct DefiEdgeTwapStrategy.NewTick[]",name:"_newTicks",type:"tuple[]"},{internalType:"bool",name:"_burnAll",type:"bool"}],name:"rebalance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_burnAll:"When burning into new ticks, should we burn all liquidity?",_existingTicks:"Array of existing ticks to rebalance",_newTicks:"New ticks in case there are any",_swapData:"Swap data to perform exchange from 1inch"},notice:"Rebalances the strategy"},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"useTwap(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"useTwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/twap/DefiEdgeTwapStrategyDeployer.sol:DefiEdgeTwapStrategyDeployer":{source:"contracts/twap/DefiEdgeTwapStrategyDeployer.sol",name:"DefiEdgeTwapStrategyDeployer",events:{"StrategyDeployed(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyDeployed",type:"event"}},methods:{"createStrategy(address,address,address,address,address,bool[2],(int24,int24)[])":{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_swapRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],name:"createStrategy",outputs:[{internalType:"address",name:"strategy",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/twap/DefiEdgeTwapStrategyFactory.sol:DefiEdgeTwapStrategyFactory":{source:"contracts/twap/DefiEdgeTwapStrategyFactory.sol",name:"DefiEdgeTwapStrategyFactory",constructor:{inputs:[{internalType:"address",name:"_governance",type:"address"},{internalType:"contract IDefiEdgeTwapStrategyDeployer",name:"_deployerProxy",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract IUniswapV3Factory",name:"_uniswapV3factory",type:"address"},{internalType:"contract IOneInchRouter",name:"_oneInchRouter",type:"address"},{internalType:"uint256",name:"_allowedSlippage",type:"uint256"},{internalType:"uint256",name:"_allowedDeviation",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},events:{"ChangeDeviation(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"deviation",type:"uint256"}],name:"ChangeDeviation",type:"event"},"ChangeProtocolFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolFee",type:"event"},"ChangeProtocolPerformanceFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolPerformanceFee",type:"event"},"ChangeSlippage(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"slippage",type:"uint256"}],name:"ChangeSlippage",type:"event"},"ChangeStrategyCreationFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ChangeStrategyCreationFee",type:"event"},"ClaimFees(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ClaimFees",type:"event"},"NewStrategy(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!0,internalType:"address",name:"creater",type:"address"}],name:"NewStrategy",type:"event"},"StrategyStatusChanged(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyStatusChanged",type:"event"},"TwapPricePeriodChanged(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"period",type:"uint256"}],name:"TwapPricePeriodChanged",type:"event"}},methods:{"MAX_DECIMAL()":{inputs:[],name:"MAX_DECIMAL",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_PROTOCOL_PERFORMANCE_FEES_RATE()":{inputs:[],name:"MAX_PROTOCOL_PERFORMANCE_FEES_RATE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"acceptGovernance()":{inputs:[],name:"acceptGovernance",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Change the operator"},"allowedDeviation()":{inputs:[],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSlippage()":{inputs:[],name:"allowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainlinkRegistry()":{inputs:[],name:"chainlinkRegistry",outputs:[{internalType:"contract FeedRegistryInterface",name:"",type:"address"}],stateMutability:"view",type:"function"},"changeAllowedSlippage(uint256)":{inputs:[{internalType:"uint256",name:"_allowedSlippage",type:"uint256"}],name:"changeAllowedSlippage",outputs:[],stateMutability:"nonpayable",type:"function"},"changeDefaultAllowedDeviation(uint256)":{inputs:[{internalType:"uint256",name:"_allowedDeviation",type:"uint256"}],name:"changeDefaultAllowedDeviation",outputs:[],stateMutability:"nonpayable",type:"function"},"changeDefaultTwapPeriod(address,uint256)":{inputs:[{internalType:"address",name:"_pool",type:"address"},{internalType:"uint256",name:"_twapPricePeriod",type:"uint256"}],name:"changeDefaultTwapPeriod",outputs:[],stateMutability:"nonpayable",type:"function",params:{_pool:"Address of the pool",_twapPricePeriod:"Timespan in seconds"},notice:"Changes default TWAP period"},"changeFeeForStrategyCreation(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeFeeForStrategyCreation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fee:"New fee in 1e18 format"},notice:"Changes strategy creation fees"},"changeFeeTo(address)":{inputs:[{internalType:"address",name:"_feeTo",type:"address"}],name:"changeFeeTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{_feeTo:"New fee to address"},notice:"Change feeTo address"},"changeGovernance(address)":{inputs:[{internalType:"address",name:"_governance",type:"address"}],name:"changeGovernance",outputs:[],stateMutability:"nonpayable",type:"function",params:{_governance:"Address of the new governance"},notice:"Change the governance address"},"changeProtocolFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeProtocolFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_fee:"New fee in 1e8 format"},notice:"Changes protocol fees"},"changeProtocolPerformanceFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_feeRate",type:"uint256"}],name:"changeProtocolPerformanceFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_feeRate:"New fee in 1e8 format"},notice:"Changes protocol performance fees"},"claimFees(address)":{inputs:[{internalType:"address",name:"_to",type:"address"}],name:"claimFees",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Governance claims fees received from strategy creation"},"createStrategy((address,address,uint256,uint256,uint256,address,bool[2],(int24,int24)[]))":{inputs:[{components:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"feeTo",type:"address"},{internalType:"uint256",name:"managementFeeRate",type:"uint256"},{internalType:"uint256",name:"performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"limit",type:"uint256"},{internalType:"contract IUniswapV3Pool",name:"pool",type:"address"},{internalType:"bool[2]",name:"useTwap",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"ticks",type:"tuple[]"}],internalType:"struct ITwapStrategyFactory.CreateStrategyParams",name:"params",type:"tuple"}],name:"createStrategy",outputs:[],stateMutability:"payable",type:"function"},"defaultTwapPricePeriod()":{inputs:[],name:"defaultTwapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"denied(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"denied",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"deny(address,bool)":{inputs:[{internalType:"address",name:"_strategy",type:"address"},{internalType:"bool",name:"_status",type:"bool"}],name:"deny",outputs:[],stateMutability:"nonpayable",type:"function",params:{_strategy:"Address of the strategy"},notice:"Adds strategy to Denylist, rebalance and add liquidity will be stopped"},"deployerProxy()":{inputs:[],name:"deployerProxy",outputs:[{internalType:"contract IDefiEdgeTwapStrategyDeployer",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getHeartBeat(address,address)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"getHeartBeat",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{_base:"base token address",_quote:"quote token address"},notice:"Fetch heartBeat for specific feeds, if hearbeat is 0 then it will return 3600 seconds by default"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isValidStrategy(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isValidStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"protocolFeeRate()":{inputs:[],name:"protocolFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"protocolPerformanceFeeRate()":{inputs:[],name:"protocolPerformanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"setMinHeartbeat(address,address,uint256)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"},{internalType:"uint256",name:"_period",type:"uint256"}],name:"setMinHeartbeat",outputs:[],stateMutability:"nonpayable",type:"function",params:{_base:"base token address",_period:"heartbeat in seconds",_quote:"quote token address"},notice:"Update heartBeat for specific feeds"},"strategyByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"strategyByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyByManager(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"strategyByManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyCreationFee()":{inputs:[],name:"strategyCreationFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalIndex()":{inputs:[],name:"totalIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"twapPricePeriod(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"twapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"uniswapV3Factory()":{inputs:[],name:"uniswapV3Factory",outputs:[{internalType:"contract IUniswapV3Factory",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/twap/base/TwapStrategyBase.sol:TwapStrategyBase":{source:"contracts/twap/base/TwapStrategyBase.sol",name:"TwapStrategyBase",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract ITwapStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"useTwap(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"useTwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/twap/base/TwapStrategyManager.sol:TwapStrategyManager":{source:"contracts/twap/base/TwapStrategyManager.sol",name:"TwapStrategyManager",constructor:{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"address"},{internalType:"address",name:"_operator",type:"address"},{internalType:"address",name:"_feeTo",type:"address"},{internalType:"uint256",name:"_managementFeeRate",type:"uint256"},{internalType:"uint256",name:"_performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"_limit",type:"uint256"},{internalType:"uint256",name:"_allowedDeviation",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},events:{"AllowedSwapDeviationChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"deviation",type:"uint256"}],name:"AllowedSwapDeviationChanged",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"EmergencyActivated()":{anonymous:!1,inputs:[],name:"EmergencyActivated",type:"event"},"FeeChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"tier",type:"uint256"}],name:"FeeChanged",type:"event"},"FeeToChanged(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"feeTo",type:"address"}],name:"FeeToChanged",type:"event"},"LimitChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"limit",type:"uint256"}],name:"LimitChanged",type:"event"},"MaxSwapLimitChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"limit",type:"uint256"}],name:"MaxSwapLimitChanged",type:"event"},"OperatorChanged(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"}],name:"OperatorChanged",type:"event"},"OperatorProposed(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"}],name:"OperatorProposed",type:"event"},"PerformanceFeeChanged(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"performanceFeeRate",type:"uint256"}],name:"PerformanceFeeChanged",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"StrategyModeUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyModeUpdated",type:"event"}},methods:{"ADMIN_ROLE()":{inputs:[],name:"ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"BURNER_ROLE()":{inputs:[],name:"BURNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MANAGER_ROLE()":{inputs:[],name:"MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MIN_DEVIATION()":{inputs:[],name:"MIN_DEVIATION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MIN_FEE()":{inputs:[],name:"MIN_FEE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"USER_WHITELIST_ROLE()":{inputs:[],name:"USER_WHITELIST_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"only can burn the liquidity"},"acceptOperator()":{inputs:[],name:"acceptOperator",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Change the operator"},"allowedSwapDeviation()":{inputs:[],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"changeFeeTo(address)":{inputs:[{internalType:"address",name:"_newFeeTo",type:"address"}],name:"changeFeeTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{_newFeeTo:"New address where fees should be received"},notice:"changes address where the operator is receiving the fee"},"changeLimit(uint256)":{inputs:[{internalType:"uint256",name:"_limit",type:"uint256"}],name:"changeLimit",outputs:[],stateMutability:"nonpayable",type:"function",params:{_limit:"Number of shares the strategy can mint, 0 means unlimited"},notice:"Change strategy limit in terms of share"},"changeManagementFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_fee",type:"uint256"}],name:"changeManagementFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",details:"1000000 is 1%",params:{_fee:"Fee tier from indexes 0 to 2"},notice:"Changes the fee"},"changeMaxSwapLimit(uint256)":{inputs:[{internalType:"uint256",name:"_limit",type:"uint256"}],name:"changeMaxSwapLimit",outputs:[],stateMutability:"nonpayable",type:"function",params:{_limit:"Maximum number of swap that can be performed in a day"},notice:"Change strategy maximum swap limit for a day"},"changeOperator(address)":{inputs:[{internalType:"address",name:"_operator",type:"address"}],name:"changeOperator",outputs:[],stateMutability:"nonpayable",type:"function",params:{_operator:"Address of the new operator"},notice:"Change the operator"},"changePerformanceFeeRate(uint256)":{inputs:[{internalType:"uint256",name:"_performanceFeeRate",type:"uint256"}],name:"changePerformanceFeeRate",outputs:[],stateMutability:"nonpayable",type:"function",params:{_performanceFeeRate:"New performance fee, should not be more than 20%"},notice:"Manager can set the performance fee"},"changeSwapDeviation(uint256)":{inputs:[{internalType:"uint256",name:"_allowedSwapDeviation",type:"uint256"}],name:"changeSwapDeviation",outputs:[],stateMutability:"nonpayable",type:"function",params:{_allowedSwapDeviation:"New allowed price deviation, 1e18 is 100%"},notice:"Changes allowed price deviation for shares and pool"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"freezeEmergency()":{inputs:[],name:"freezeEmergency",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"freezeEmergencyFunctions()":{inputs:[],name:"freezeEmergencyFunctions",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Freeze emergency function, can be done only once"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getRoleMember(bytes32,uint256)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"uint256",name:"index",type:"uint256"}],name:"getRoleMember",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information."},"getRoleMemberCount(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleMemberCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"increamentSwapCounter()":{inputs:[],name:"increamentSwapCounter",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Track total swap performed in a day and revert if maximum swap limit reached.         Can only be called by strategy contract"},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isStrategyPrivate()":{inputs:[],name:"isStrategyPrivate",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUserWhiteListed(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isUserWhiteListed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"lastSwapTimestamp()":{inputs:[],name:"lastSwapTimestamp",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"limit()":{inputs:[],name:"limit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"managementFeeRate()":{inputs:[],name:"managementFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"maxAllowedSwap()":{inputs:[],name:"maxAllowedSwap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operator()":{inputs:[],name:"operator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingOperator()":{inputs:[],name:"pendingOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"performanceFeeRate()":{inputs:[],name:"performanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"strategy()":{inputs:[],name:"strategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"swapCounter()":{inputs:[],name:"swapCounter",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"twapPricePeriod()":{inputs:[],name:"twapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"If default price of the twap is not setup for the strategy,  return default value from the factory",notice:"Returns latest twap price period"},"updateStrategyMode(bool)":{inputs:[{internalType:"bool",name:"_isPrivate",type:"bool"}],name:"updateStrategyMode",outputs:[],stateMutability:"nonpayable",type:"function",params:{_isPrivate:"true - private strategy, false - public strategy"},notice:"Manager can update strategy mode -  public, private"}}},"contracts/twap/base/UniswapV3TwapLiquidityManager.sol:UniswapV3TwapLiquidityManager":{source:"contracts/twap/base/UniswapV3TwapLiquidityManager.sol",name:"UniswapV3TwapLiquidityManager",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"},"FeesClaim(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!1,internalType:"uint256",name:"amount0",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amount1",type:"uint256"}],name:"FeesClaim",type:"event"},"Swap(uint256,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amountIn",type:"uint256"},{indexed:!1,internalType:"uint256",name:"amountOut",type:"uint256"},{indexed:!1,internalType:"bool",name:"_zeroForOne",type:"bool"}],name:"Swap",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"FEE_PRECISION()":{inputs:[],name:"FEE_PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MAX_TICK_LENGTH()":{inputs:[],name:"MAX_TICK_LENGTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"MINIMUM_LIQUIDITY()":{inputs:[],name:"MINIMUM_LIQUIDITY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowance(address,address)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnLiquiditySingle(uint256)":{inputs:[{internalType:"uint256",name:"_tickIndex",type:"uint256"}],name:"burnLiquiditySingle",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"fee0",type:"uint256"},{internalType:"uint256",name:"fee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_tickIndex:"Index of tick which needs to be burned"},notice:"Burn liquidity from specific tick"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Claims the fee for protocol and management Protocol receives X percentage from manager fee"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"getAUMWithFees(bool)":{inputs:[{internalType:"bool",name:"_includeFee",type:"bool"}],name:"getAUMWithFees",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"uint256",name:"totalFee0",type:"uint256"},{internalType:"uint256",name:"totalFee1",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{_includeFee:"Whether to include pool fees in AUM or not. (passing true will also collect fees from pool)"},notice:"Get's assets under management with realtime fees"},"getTicks()":{inputs:[],name:"getTicks",outputs:[{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",notice:"Returns the current ticks"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract ITwapStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"swap(bytes)":{inputs:[{internalType:"bytes",name:"data",type:"bytes"}],name:"swap",outputs:[],stateMutability:"nonpayable",type:"function",params:{data:"Swap data to perform exchange from 1inch"},notice:"Swap the fudns to 1Inch"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"ticks(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"ticks",outputs:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],stateMutability:"view",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."},"uniswapV3MintCallback(uint256,uint256,bytes)":{inputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"uniswapV3MintCallback",outputs:[],stateMutability:"nonpayable",type:"function",details:"Callback for Uniswap V3 pool."},"useTwap(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"useTwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/twap/interfaces/IDefiEdgeTwapStrategyDeployer.sol:IDefiEdgeTwapStrategyDeployer":{source:"contracts/twap/interfaces/IDefiEdgeTwapStrategyDeployer.sol",name:"IDefiEdgeTwapStrategyDeployer",events:{"StrategyDeployed(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"strategy",type:"address"}],name:"StrategyDeployed",type:"event"}},methods:{"createStrategy(address,address,address,address,address,bool[2],(int24,int24)[])":{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"address"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"address"},{internalType:"contract IOneInchRouter",name:"_swapRouter",type:"address"},{internalType:"contract FeedRegistryInterface",name:"_chainlinkRegistry",type:"address"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"address"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"_ticks",type:"tuple[]"}],name:"createStrategy",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function"}}},"contracts/twap/interfaces/ITwapStrategyBase.sol:ITwapStrategyBase":{source:"contracts/twap/interfaces/ITwapStrategyBase.sol",name:"ITwapStrategyBase",events:{"ClaimFee(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"managerFee",type:"uint256"},{indexed:!1,internalType:"uint256",name:"protocolFee",type:"uint256"}],name:"ClaimFee",type:"event"}},methods:{"accManagementFeeShares()":{inputs:[],name:"accManagementFeeShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"claimFee()":{inputs:[],name:"claimFee",outputs:[],stateMutability:"nonpayable",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"manager()":{inputs:[],name:"manager",outputs:[{internalType:"contract ITwapStrategyManager",name:"",type:"address"}],stateMutability:"view",type:"function"},"onHold()":{inputs:[],name:"onHold",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pool()":{inputs:[],name:"pool",outputs:[{internalType:"contract IUniswapV3Pool",name:"",type:"address"}],stateMutability:"view",type:"function"},"useTwap(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"useTwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"}}},"contracts/twap/interfaces/ITwapStrategyFactory.sol:ITwapStrategyFactory":{source:"contracts/twap/interfaces/ITwapStrategyFactory.sol",name:"ITwapStrategyFactory",events:{"ChangeDeviation(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"deviation",type:"uint256"}],name:"ChangeDeviation",type:"event"},"ChangeProtocolFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolFee",type:"event"},"ChangeProtocolPerformanceFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"fee",type:"uint256"}],name:"ChangeProtocolPerformanceFee",type:"event"},"ChangeSlippage(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"slippage",type:"uint256"}],name:"ChangeSlippage",type:"event"},"ChangeStrategyCreationFee(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ChangeStrategyCreationFee",type:"event"},"ClaimFees(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"ClaimFees",type:"event"},"NewStrategy(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"strategy",type:"address"},{indexed:!0,internalType:"address",name:"creater",type:"address"}],name:"NewStrategy",type:"event"},"StrategyStatusChanged(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"status",type:"bool"}],name:"StrategyStatusChanged",type:"event"},"TwapPricePeriodChanged(address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"pool",type:"address"},{indexed:!1,internalType:"uint256",name:"period",type:"uint256"}],name:"TwapPricePeriodChanged",type:"event"}},methods:{"allowedDeviation()":{inputs:[],name:"allowedDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowedSlippage()":{inputs:[],name:"allowedSlippage",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"chainlinkRegistry()":{inputs:[],name:"chainlinkRegistry",outputs:[{internalType:"contract FeedRegistryInterface",name:"",type:"address"}],stateMutability:"view",type:"function"},"createStrategy((address,address,uint256,uint256,uint256,address,bool[2],(int24,int24)[]))":{inputs:[{components:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"feeTo",type:"address"},{internalType:"uint256",name:"managementFeeRate",type:"uint256"},{internalType:"uint256",name:"performanceFeeRate",type:"uint256"},{internalType:"uint256",name:"limit",type:"uint256"},{internalType:"contract IUniswapV3Pool",name:"pool",type:"address"},{internalType:"bool[2]",name:"useTwap",type:"bool[2]"},{components:[{internalType:"int24",name:"tickLower",type:"int24"},{internalType:"int24",name:"tickUpper",type:"int24"}],internalType:"struct ITwapStrategyBase.Tick[]",name:"ticks",type:"tuple[]"}],internalType:"struct ITwapStrategyFactory.CreateStrategyParams",name:"params",type:"tuple"}],name:"createStrategy",outputs:[],stateMutability:"payable",type:"function"},"defaultTwapPricePeriod()":{inputs:[],name:"defaultTwapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"denied(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"denied",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"deployerProxy()":{inputs:[],name:"deployerProxy",outputs:[{internalType:"contract IDefiEdgeTwapStrategyDeployer",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getHeartBeat(address,address)":{inputs:[{internalType:"address",name:"_base",type:"address"},{internalType:"address",name:"_quote",type:"address"}],name:"getHeartBeat",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"governance()":{inputs:[],name:"governance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"isValidStrategy(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isValidStrategy",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"oneInchRouter()":{inputs:[],name:"oneInchRouter",outputs:[{internalType:"contract IOneInchRouter",name:"",type:"address"}],stateMutability:"view",type:"function"},"pendingGovernance()":{inputs:[],name:"pendingGovernance",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"protocolFeeRate()":{inputs:[],name:"protocolFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"protocolPerformanceFeeRate()":{inputs:[],name:"protocolPerformanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"strategyByIndex(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"strategyByIndex",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyByManager(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"strategyByManager",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"strategyCreationFee()":{inputs:[],name:"strategyCreationFee",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalIndex()":{inputs:[],name:"totalIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"twapPricePeriod(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"twapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"uniswapV3Factory()":{inputs:[],name:"uniswapV3Factory",outputs:[{internalType:"contract IUniswapV3Factory",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/twap/interfaces/ITwapStrategyManager.sol:ITwapStrategyManager":{source:"contracts/twap/interfaces/ITwapStrategyManager.sol",name:"ITwapStrategyManager",methods:{"allowedSwapDeviation()":{inputs:[],name:"allowedSwapDeviation",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"factory()":{inputs:[],name:"factory",outputs:[{internalType:"contract ITwapStrategyFactory",name:"",type:"address"}],stateMutability:"view",type:"function"},"feeTo()":{inputs:[],name:"feeTo",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"freezeEmergency()":{inputs:[],name:"freezeEmergency",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"increamentSwapCounter()":{inputs:[],name:"increamentSwapCounter",outputs:[],stateMutability:"nonpayable",type:"function"},"isAllowedToBurn(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isAllowedToBurn",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isAllowedToManage(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isAllowedToManage",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"isUserWhiteListed(address)":{inputs:[{internalType:"address",name:"_account",type:"address"}],name:"isUserWhiteListed",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"limit()":{inputs:[],name:"limit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"managementFeeRate()":{inputs:[],name:"managementFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"operator()":{inputs:[],name:"operator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"performanceFeeRate()":{inputs:[],name:"performanceFeeRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"twapPricePeriod()":{inputs:[],name:"twapPricePeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/twap/libraries/TwapOracleLibrary.sol:TwapOracleLibrary":{source:"contracts/twap/libraries/TwapOracleLibrary.sol",name:"TwapOracleLibrary",methods:{"BASE()":{inputs:[],name:"BASE",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"allowSwap(IUniswapV3Pool,ITwapStrategyFactory,uint256,uint256,address,address,ITwapStrategyManager,bool[2])":{inputs:[{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"ITwapStrategyFactory"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"ITwapStrategyManager"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"}],name:"allowSwap",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_factory:"Address of the DefiEdge strategy factory",_pool:"Address of the pool",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped"},returns:{_0:"true if the swap is allowed, else false"},notice:"Checks for price slippage at the time of swap"},"isSwapExceedDeviation(ITwapStrategyFactory,IUniswapV3Pool,FeedRegistryInterface,uint256,uint256,address,address,ITwapStrategyManager,bool[2])":{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"ITwapStrategyFactory"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract FeedRegistryInterface",name:"_registry",type:"FeedRegistryInterface"},{internalType:"uint256",name:"_amountIn",type:"uint256"},{internalType:"uint256",name:"_amountOut",type:"uint256"},{internalType:"address",name:"_tokenIn",type:"address"},{internalType:"address",name:"_tokenOut",type:"address"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"ITwapStrategyManager"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"}],name:"isSwapExceedDeviation",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{_amountIn:"Amount to be swapped",_amountOut:"Amount received after swap",_manager:"Manager contract address to check allowed deviation",_pool:"Address of the pool",_registry:"Chainlink registry interface",_tokenIn:"Token to be swapped",_tokenOut:"Token to which tokenIn should be swapped"},notice:"Checks the if swap exceed allowed swap deviation or not"}}},"contracts/twap/libraries/TwapShareHelper.sol:TwapShareHelper":{source:"contracts/twap/libraries/TwapShareHelper.sol",name:"TwapShareHelper",methods:{"DIVISOR()":{inputs:[],name:"DIVISOR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"calculateFeeShares(ITwapStrategyFactory,ITwapStrategyManager,uint256)":{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"ITwapStrategyFactory"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"ITwapStrategyManager"},{internalType:"uint256",name:"_accManagementFee",type:"uint256"}],name:"calculateFeeShares",outputs:[{internalType:"address",name:"managerFeeTo",type:"address"},{internalType:"address",name:"protocolFeeTo",type:"address"},{internalType:"uint256",name:"managerShare",type:"uint256"},{internalType:"uint256",name:"protocolShare",type:"uint256"}],stateMutability:"view",type:"function",params:{_accManagementFee:"Accumulated management fees in terms of shares, decimal 18",_factory:"Strategy factory address",_manager:"Strategy manager contract address"},notice:"Calculates the fee shares from accumulated fees"},"calculateFeeTokenShares(ITwapStrategyFactory,ITwapStrategyManager,uint256,uint256)":{inputs:[{internalType:"contract ITwapStrategyFactory",name:"_factory",type:"ITwapStrategyFactory"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"ITwapStrategyManager"},{internalType:"uint256",name:"_fee0",type:"uint256"},{internalType:"uint256",name:"_fee1",type:"uint256"}],name:"calculateFeeTokenShares",outputs:[{internalType:"address",name:"managerFeeTo",type:"address"},{internalType:"address",name:"protocolFeeTo",type:"address"},{internalType:"uint256",name:"managerToken0Amount",type:"uint256"},{internalType:"uint256",name:"managerToken1Amount",type:"uint256"},{internalType:"uint256",name:"protocolToken0Amount",type:"uint256"},{internalType:"uint256",name:"protocolToken1Amount",type:"uint256"}],stateMutability:"view",type:"function",params:{_factory:"Strategy factory address",_fee0:"Accumulated token0 fee amount",_fee1:"Accumulated token1  fee amount",_manager:"Strategy manager contract address"},notice:"Calculates the fee shares from accumulated fees"},"calculateShares(FeedRegistryInterface,IUniswapV3Pool,ITwapStrategyManager,bool[2],uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"contract FeedRegistryInterface",name:"_registry",type:"FeedRegistryInterface"},{internalType:"contract IUniswapV3Pool",name:"_pool",type:"IUniswapV3Pool"},{internalType:"contract ITwapStrategyManager",name:"_manager",type:"ITwapStrategyManager"},{internalType:"bool[2]",name:"_useTwap",type:"bool[2]"},{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"},{internalType:"uint256",name:"_totalShares",type:"uint256"}],name:"calculateShares",outputs:[{internalType:"uint256",name:"share",type:"uint256"}],stateMutability:"view",type:"function",details:"Calculates the shares to be given for specific position",params:{_amount0:"Amount of token0",_amount1:"Amount of token1",_pool:"The token0",_registry:"Chainlink registry interface",_totalAmount0:"Total amount of token0",_totalAmount1:"Total amount of token1",_totalShares:"Total Number of shares"}},"getOptimalAmounts(uint256,uint256,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"_amount0",type:"uint256"},{internalType:"uint256",name:"_amount1",type:"uint256"},{internalType:"uint256",name:"_amount0Min",type:"uint256"},{internalType:"uint256",name:"_amount1Min",type:"uint256"},{internalType:"uint256",name:"_totalAmount0",type:"uint256"},{internalType:"uint256",name:"_totalAmount1",type:"uint256"}],name:"getOptimalAmounts",outputs:[{internalType:"uint256",name:"amount0",type:"uint256"},{internalType:"uint256",name:"amount1",type:"uint256"}],stateMutability:"pure",type:"function"}}}};new jn({el:"#app",router:new Tu({routes:[{path:"/",component:Nu,props:()=>({json:Vu})},{path:"*",component:qu,props:e=>({json:Vu[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(ku)})})()})();